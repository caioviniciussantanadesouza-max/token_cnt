<!doctype html>

<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>cnt — centro natural tec amazônia</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>


<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
  overflow:hidden;
}
#app{
  position:fixed; inset:0;
  display:grid;
  grid-template-columns: 300px 1fr 360px;
  grid-template-rows: 120px minmax(0,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:14px 16px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:8px;
}
#header h1{
  margin:0;
  font-size:26px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}

/* Left */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:56px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }

.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }

#status{
  margin-top:4px;
  font-size:10px;
  color:rgba(180,245,255,.9);
  opacity:.88;
  line-height:1.25;
}

/* Center */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
#leaflet{ z-index:0; }
#holo{ z-index:2; }
#dots{ z-index:3; }
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.22;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.22), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.16), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.10), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
}
@keyframes glowPulse{
  0%{ opacity:.16; transform:scale(1); }
  50%{ opacity:.30; transform:scale(1.02); }
  100%{ opacity:.16; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }

.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }

#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
}

@media (max-width: 1100px){
  body{ overflow:auto; }
  #app{ position:relative; grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; }
  #center{ height:48vh; }
}

#leaflet{ position:absolute; inset:0; z-index:0; }
#cnvBase{ z-index:1; }
#cnvBorder{ z-index:2; }
#cnvLines{ z-index:3; }
#cnvPoints{ z-index:4; }
#wave{ z-index:5; }

</style>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — centro natural tec amazônia</h1>
    <p class="sub">Mapa ecológico real • Água (azul) • Vegetação (verde) • Transição (amarelo) • Desmatamento (vermelho)</p>
    <div id="chips">
      <div class="chip">Fonte: dados públicos governamentais</div>
      <div class="chip">Ano base: 2025</div>
      <div class="chip">Pontos reais (sample → full)</div>
      <div class="chip">Compra: Pump.fun</div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

```
<div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
<div class="small">RAW auditável: <b id="raw">--</b></div>

<div class="hr"></div>

<div class="abclist">
  <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
  <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
  <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
  <div class="abcline"><b>Grau</b><span id="R">--</span></div>
</div>

<div class="hr"></div>

<div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
<div class="grid2">
  <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
  <div class="kv"><b>IAB</b><span id="iab">--</span></div>
  <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
  <div class="kv"><b>HID</b><span id="hid">--</span></div>
  <div class="kv"><b>ENT</b><span id="ent">--</span></div>
  <div class="kv"><b>PAN</b><span id="pan">--</span></div>
</div>

<div style="display:flex; gap:10px; align-items:center;">
  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
<div id="status">status: iniciando…</div>
<div id="yearchip" class="chip">ano: 2000</div>
</div>
```

  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <div id="leaflet" class="layer"></div>
      <canvas id="cnvBase" class="layer"></canvas>
      <canvas id="cnvBorder" class="layer"></canvas>
      <canvas id="cnvLines" class="layer"></canvas>
      <canvas id="cnvPoints" class="layer"></canvas>
      <div id="mapGlow"></div>
      <div id="scanlines"></div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>
      <p class="mut">Abre o token no Pump.fun.</p>

```
  <label for="sol">Contribuição</label>
  <div class="row">
    <input id="sol" type="number" step="0.01" min="0" value="0.10" />
    <button class="btn" id="btnBuy">Comprar no Pump</button>
  </div>

  <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
  <div class="smallnote">Estimativa demo (não é cotação real).</div>
</div>

<div id="telemetry" class="glass">
  <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
  <canvas id="wave"></canvas>
  <div id="telemetryHint">Carregando…</div>
</div>
```

  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const PUMP_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";
const rate = 147449130;

const FILES = {
  biomas: "biomas.geojson",
  br_simpl: "br_ibge_simplificado.geojson",
  br_full: "br_ibge_simplificado.geojson",
  uf: "uf.geojson",
  macro: "macro_rh.geojson",
  micro: "micro_rh.geojson",
  cnt: "cnt_full_10y.geojson",
  pts_sample: "vege_pts_sample.geojson",
  pts_full: "vege_pts.geojson"
};

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

async function loadJSON(name){
  const url = "./" + name + "?v=" + Date.now();
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error(`${name} HTTP ${res.status} (${url})`);
  const txt = await res.text();
  try{ return JSON.parse(txt); }
  catch(e){ throw new Error(`${name}: JSON inválido / truncado`); }
}

async function loadEither(a,b){
  try{ return await loadJSON(a); }
  catch(e1){
    try{ return await loadJSON(b); }
    catch(e2){ throw e1; }
  }
}

function walkCoords(arr, cb){
  if(!arr) return;
  if(typeof arr[0] === "number") cb(arr);
  else for(const a of arr) walkCoords(a, cb);
}
function calcBBox(fc){
  let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    walkCoords(g.coordinates, (c)=>{
      const x=c[0], y=c[1];
      if(x<minx)minx=x; if(y<miny)miny=y;
      if(x>maxx)maxx=x; if(y>maxy)maxy=y;
    });
  }
  return [minx, miny, maxx, maxy];
}

/* proj */
let bbox = null;
function proj(lon,lat,w,h){
  const [minx,miny,maxx,maxy] = bbox;
  return [
    (lon-minx)/(maxx-minx)*w,
    (maxy-lat)/(maxy-miny)*h
  ];
}

/* =========================
   CANVAS
========================= */
const cnvBase   = document.getElementById("cnvBase");
const cnvBorder = document.getElementById("cnvBorder");
const cnvLines  = document.getElementById("cnvLines");
const cnvPoints = document.getElementById("cnvPoints");

const ctxBase = cnvBase.getContext("2d");
const ctxB    = cnvBorder.getContext("2d");
const ctxL    = cnvLines.getContext("2d");
const ctxP    = cnvPoints.getContext("2d");

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const r = cnv.getBoundingClientRect();
  cnv.width  = Math.floor(r.width * dpr);
  cnv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function resizeAll(){
  resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvBorder, ctxB);
  resizeCanvas(cnvLines, ctxL);
  resizeCanvas(cnvPoints, ctxP);
  resizeWave();
  if(state.ready) redrawStatic();
}
window.addEventListener("resize", resizeAll);

function clearAll(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctxBase.clearRect(0,0,W,H);
  ctxB.clearRect(0,0,W,H);
  ctxL.clearRect(0,0,W,H);
  ctxP.clearRect(0,0,W,H);
}

/* =========================
   STATE
========================= */
const state = {
  ready:false,
  biomas:null,
  brasilMask:null,
  uf:null,
  macro:null,
  micro:null,
  cnt:null,
  ptsFC:null,
  ptsXY:[],
  grid:null,
  // tuning visual (mais parecido com referência)
  gridSize:22,
  R:22,
  target:11,
  t:0,
  animStarted:false
};

/* =========================
   DRAW SHAPES
========================= */
function fillPolygons(ctx, fc, fillStyle, alpha){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = fillStyle;

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    const polys = (g.type==="Polygon") ? [g.coordinates] : (g.type==="MultiPolygon" ? g.coordinates : []);
    for(const poly of polys){
      const outer = poly[0];
      if(!outer || outer.length<3) continue;
      ctx.beginPath();
      for(let i=0;i<outer.length;i++){
        const [x,y] = proj(outer[i][0], outer[i][1], W, H);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fill();
    }
  }
  ctx.restore();
}

function strokePolygonsGlow(ctx, fc){
  const W = cnvBorder.getBoundingClientRect().width;
  const H = cnvBorder.getBoundingClientRect().height;

  ctx.save();
  ctx.lineJoin="round";
  ctx.lineCap="round";

  const drawOuter = ()=>{
    for(const f of (fc.features||[])){
      const g = f.geometry;
      if(!g) continue;
      const polys = (g.type==="Polygon") ? [g.coordinates] : (g.type==="MultiPolygon" ? g.coordinates : []);
      for(const poly of polys){
        const outer = poly[0];
        if(!outer || outer.length<3) continue;
        ctx.beginPath();
        for(let i=0;i<outer.length;i++){
          const [x,y] = proj(outer[i][0], outer[i][1], W, H);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  };

  ctx.shadowColor = "rgba(0,255,220,0.95)";
  ctx.shadowBlur  = 28;
  ctx.lineWidth   = 4.8;
  ctx.strokeStyle = "rgba(0,255,220,0.55)";
  drawOuter();

  ctx.shadowBlur  = 12;
  ctx.lineWidth   = 2.2;
  ctx.strokeStyle = "rgba(0,255,220,0.95)";
  drawOuter();

  ctx.restore();
}

function strokeLines(ctx, fc, strokeStyle, width, alpha){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = width;
  ctx.lineJoin="round";
  ctx.lineCap="round";

  const drawLine = (line)=>{
    if(!line || line.length<2) return;
    ctx.beginPath();
    for(let i=0;i<line.length;i++){
      const [x,y]=proj(line[i][0], line[i][1], W, H);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  };

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    if(g.type==="LineString") drawLine(g.coordinates);
    else if(g.type==="MultiLineString") for(const ln of g.coordinates) drawLine(ln);
    else if(g.type==="Polygon") drawLine(g.coordinates[0]);
    else if(g.type==="MultiPolygon") for(const poly of g.coordinates) drawLine(poly[0]);
  }

  ctx.restore();
}

function maskCanvasToBrasil(ctx){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  ctx.save();
  ctx.globalCompositeOperation = "destination-in";
  ctx.fillStyle = "#fff";
  ctx.beginPath();

  for(const f of (state.brasilMask.features||[])){
    const g = f.geometry;
    if(!g) continue;
    const polys = (g.type==="Polygon") ? [g.coordinates] : (g.type==="MultiPolygon" ? g.coordinates : []);
    for(const poly of polys){
      const outer = poly[0];
      if(!outer || outer.length<3) continue;
      for(let i=0;i<outer.length;i++){
        const [x,y] = proj(outer[i][0], outer[i][1], W, H);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }
  }

  ctx.fill();
  ctx.restore();
  ctx.globalCompositeOperation = "source-over";
}

/* =========================
   POINTS + GRID (densidade)
========================= */
function buildProjectedPoints(fc){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  const pts = [];
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g || g.type!=="Point") continue;
    const [x,y] = proj(g.coordinates[0], g.coordinates[1], W, H);
    pts.push({ x,y, ph: Math.random()*Math.PI*2, sp: 0.7+Math.random()*1.3, base: 0.6+Math.random()*0.8 });
  }

  // LIMITADOR (pra FULL não travar)
  const MAX = 140000;
  if(pts.length > MAX){
    const step = Math.ceil(pts.length / MAX);
    const slim = [];
    for(let i=0;i<pts.length;i+=step) slim.push(pts[i]);
    state.ptsXY = slim;
  } else {
    state.ptsXY = pts;
  }

  buildGrid();
}

function buildGrid(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  const s = state.gridSize;

  const cols = Math.ceil(W/s);
  const rows = Math.ceil(H/s);
  const grid = new Array(cols*rows);
  for(let i=0;i<grid.length;i++) grid[i]=[];

  const idxOf = (x,y)=>{
    const cx = Math.max(0, Math.min(cols-1, (x/s)|0));
    const cy = Math.max(0, Math.min(rows-1, (y/s)|0));
    return cy*cols + cx;
  };

  for(let i=0;i<state.ptsXY.length;i++){
    const p = state.ptsXY[i];
    grid[idxOf(p.x,p.y)].push(i);
  }

  state.grid = {grid, cols, rows, s};
}

function densityAt(x,y){
  const g = state.grid;
  if(!g) return 0;

  const R = state.R;
  const R2 = R*R;

  const cx = (x/g.s)|0;
  const cy = (y/g.s)|0;

  let count = 0;
  for(let oy=-1; oy<=1; oy++){
    for(let ox=-1; ox<=1; ox++){
      const nx = cx+ox, ny = cy+oy;
      if(nx<0 || ny<0 || nx>=g.cols || ny>=g.rows) continue;
      const bucket = g.grid[ny*g.cols + nx];
      for(const pi of bucket){
        const p = state.ptsXY[pi];
        const dx = x - p.x, dy = y - p.y;
        if(dx*dx + dy*dy <= R2) count++;
      }
    }
  }
  return count;
}

function colorForDensity(count){
  const norm = Math.min(1, count / state.target);

  // verde (bom) -> amarelo (transição) -> vermelho (pressão)
  if(norm >= 0.70) return [60, 255, 180];   // verde
  if(norm >= 0.40) return [255, 235, 90];   // amarelo
  return [255, 80, 60];                     // vermelho
}

/* =========================
   STATIC REDRAW (mapa sempre aparece)
========================= */
function redrawStatic(){
  if(!bbox) return;
  clearAll();

  // base leve
  fillPolygons(ctxBase, state.biomas, "rgba(0,255,200,1)", 0.035);
  maskCanvasToBrasil(ctxBase);

  // borda
  strokePolygonsGlow(ctxB, state.brasilMask);

  // linhas (água e limites)
  strokeLines(ctxL, state.macro, "rgba(0,234,255,0.90)", 1.15, 1);
  strokeLines(ctxL, state.micro, "rgba(0,120,255,0.60)", 0.55, 1);
  strokeLines(ctxL, state.uf,    "rgba(160,245,255,0.70)", 1.05, 1);
  maskCanvasToBrasil(ctxL);
}

/* =========================
   ANIMAÇÃO (pontos pequenos + brilho)
========================= */
function startAnim(){
  if(state.animStarted) return;
  state.animStarted = true;

  let _last = performance.now();

  const loop = ()=>{
    const _now = performance.now();
    const _dt = Math.min(0.05, (_now - _last)/1000);
    _last = _now;
    const W = cnvPoints.getBoundingClientRect().width;
    const H = cnvPoints.getBoundingClientRect().height;
    ctxP.clearRect(0,0,W,H);

    if(state.ptsXY.length){
      ctxP.globalCompositeOperation = "lighter";

      // 1) micro pontos (bem pequenos)
      for(const p of state.ptsXY){
        const count = densityAt(p.x, p.y);
        const [r,g,b] = colorForDensity(count);

        const pulse = 0.55 + 0.45*Math.sin(p.ph + state.t*p.sp*0.025);
        const alpha = (0.08 + 0.28*pulse);
        const rad   = 0.38 + p.base*0.42; // pequeno

        ctxP.beginPath();
        ctxP.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctxP.arc(p.x, p.y, rad, 0, Math.PI*2);
        ctxP.fill();
      }

      // 2) “sparkles” (dá o efeito referência)
      const glowCount = Math.min(1800, Math.max(500, (state.ptsXY.length/14)|0));
      ctxP.save();
      ctxP.shadowBlur = 10;
      for(let i=0;i<glowCount;i++){
        const p = state.ptsXY[(Math.random()*state.ptsXY.length)|0];
        if(!p) continue;

        const count = densityAt(p.x, p.y);
        const [r,g,b] = colorForDensity(count);

        const pulse = 0.55 + 0.45*Math.sin(p.ph + state.t*0.03);
        const alpha = 0.06 + 0.18*pulse;

        ctxP.shadowColor = `rgba(${r},${g},${b},${0.55})`;
        ctxP.fillStyle   = `rgba(${r},${g},${b},${alpha})`;

        ctxP.beginPath();
        ctxP.arc(p.x, p.y, 1.2 + pulse*1.5, 0, Math.PI*2);
        ctxP.fill();
      }
      ctxP.restore();

      // 3) pings infinitos (cidades/rios)
      try{ stepPings(_dt); drawPings(ctxP); }catch(e){}

      // recorte BR
      maskCanvasToBrasil(ctxP);
      ctxP.globalCompositeOperation = "source-over";
    }

    state.t++;
    requestAnimationFrame(loop);
  };
  loop();
}

/* =========================
   TELEMETRY
========================= */
const wave = document.getElementById("wave");
const wctx = wave.getContext("2d");
let tWave=0;
function resizeWave(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  wave.width = Math.floor(wave.clientWidth * dpr);
  wave.height = Math.floor(wave.clientHeight * dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0);
}
function startWave(series){
  const s = Array.isArray(series) ? series : [];
  const draw = ()=>{
    const W = wave.clientWidth, H = wave.clientHeight;
    wctx.clearRect(0,0,W,H);
    wctx.fillStyle = "rgba(0,0,0,.25)";
    wctx.fillRect(0,0,W,H);

    wctx.strokeStyle = "rgba(110,210,255,.10)";
    wctx.lineWidth = 1;
    for(let y=12; y<H; y+=18){
      wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
    }

    const min = s.length? Math.min(...s) : 0;
    const max = s.length? Math.max(...s) : 1;

    function yAt(i){
      if(s.length>=2){
        const idx = (i / (W-1)) * (s.length-1);
        const a = Math.floor(idx);
        const b = Math.min(s.length-1, a+1);
        const f = idx - a;
        const v = s[a]*(1-f) + s[b]*f;
        const norm = (max-min) < 1e-9 ? 0.5 : (v - min) / (max - min);
        let y = (H*0.18) + (1-norm) * (H*0.68);
        y += Math.sin((i + tWave)/28) * (H*0.02);
        return y;
      }
      return (H*0.52)
        + Math.sin((i+tWave)/38)*(H*0.20)
        + Math.sin((i+tWave)/13)*(H*0.07);
    }

    wctx.lineWidth = 2;
    wctx.strokeStyle = "rgba(110,210,255,.35)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    wctx.strokeStyle = "rgba(110,210,255,.90)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    tWave += 2;
    requestAnimationFrame(draw);
  };
  draw();
}

/* =========================
   BUY
========================= */
const solInput = document.getElementById("sol");
const out = document.getElementById("out");
function updateOut(){
  const sol = parseFloat(solInput.value) || 0;
  out.textContent = (sol * rate).toLocaleString("pt-BR") + " CNT";
}
solInput.addEventListener("input", updateOut);
updateOut();
document.getElementById("btnBuy").addEventListener("click", ()=>{
  window.open(PUMP_URL, "_blank", "noopener,noreferrer");
});

/* =========================
   BOOT
========================= */
async function boot(){
  try{
    statusEl.textContent = "Status: carregando camadas base…";

    // base
    state.biomas = await loadJSON(FILES.biomas);
    state.brasilMask = await loadEither(FILES.br_simpl, FILES.br_full);
    state.uf = await loadJSON(FILES.uf);
    state.macro = await loadJSON(FILES.macro);
    state.micro = await loadJSON(FILES.micro);
    state.cnt = await loadJSON(FILES.cnt);

    bbox = calcBBox(state.biomas);

    // HUD CNT
    const props = state.cnt?.features?.[0]?.properties || {};
    const rawA = Number(props.cnt_A);
    const A100 = Number.isFinite(rawA) ? clamp(rawA * 4, 0, 100) : NaN;

    document.getElementById("raw").textContent = fmt(rawA,2);
    document.getElementById("eco").textContent = fmt1(A100);
    document.getElementById("A").textContent   = fmt(A100,2);

    const b = Number(props.cnt_B);
    document.getElementById("B").textContent = Number.isFinite(b) ? ((b>=0?"+":"") + fmt(b,2)) : "--";
    document.getElementById("C").textContent = fmt(props.cnt_C,2);
    document.getElementById("R").textContent = props.grade || "--";

    document.getElementById("ibe").textContent = Number.isFinite(Number(props.FUNC)) ? fmt(props.FUNC,1) : "--";
    document.getElementById("iab").textContent = Number.isFinite(Number(props.IAB))  ? fmt(props.IAB,1)  : "N/D";
    document.getElementById("ibi").textContent = Number.isFinite(Number(props.IBI))  ? fmt(props.IBI,1)  : "--";
    document.getElementById("hid").textContent = Number.isFinite(Number(props.HID))  ? fmt(props.HID,2)  : "--";
    document.getElementById("ent").textContent = Number.isFinite(Number(props.ENT))  ? fmt(props.ENT,1)  : "--";
    document.getElementById("pan").textContent = Number.isFinite(Number(props.PAN))  ? fmt(props.PAN,1)  : "--";

    const series = Array.isArray(props.series_10y) ? props.series_10y.map(Number).filter(Number.isFinite) : [];
    document.getElementById("telemetryHint").textContent = series.length
      ? ("Histórico: " + series.length + " • Último (RAW): " + fmt(rawA,2))
      : "Sem série 10y no GeoJSON.";
    resizeAll();
    state.ready = true;

    // desenha mapa imediatamente (SEM pontos)
    redrawStatic();
    startWave(series);

    // carrega pontos sample primeiro (rápido)
    statusEl.textContent = "Status: mapa base OK • carregando pontos (sample)…";
    const ptsSample = await loadJSON(FILES.pts_sample);
    state.ptsFC = ptsSample;
    buildProjectedPoints(ptsSample);
    startAnim();
    statusEl.textContent = `Status: pontos sample OK • exibindo ${state.ptsXY.length.toLocaleString("pt-BR")} pontos • tentando FULL…`;

    // tenta FULL em seguida (se existir e se aguentar)
    setTimeout(async ()=>{
      try{
        const ptsFull = await loadJSON(FILES.pts_full);
        state.ptsFC = ptsFull;
        buildProjectedPoints(ptsFull);
        statusEl.textContent = `Status: FULL OK • exibindo ${state.ptsXY.length.toLocaleString("pt-BR")} pontos (cap)`;
      }catch(e){
        statusEl.textContent = `Status: FULL indisponível • mantendo sample (${state.ptsXY.length.toLocaleString("pt-BR")} pts)`;
      }
    }, 250);

  }catch(err){
    console.error(err);
    statusEl.textContent = "Status: ERRO • " + (err?.message || err);
    document.getElementById("telemetryHint").textContent = "Erro: arquivos não carregaram. Veja o console (F12).";
  }
}

/* =========================
   year loop 2000–2025 + camadas reais (wms)
   - verde: mapbiomas (uso/cobertura) via wms do plugin (solved)
   - amarelo: terrabrasilis (prodes/deter) via wms
   - azul: ibge hidrografia via wms
   - vermelho: capitais (centros urbanos reais) + ping infinito
========================= */
const yearChip = document.getElementById("yearchip");

const YEAR_MIN = 2000;
const YEAR_MAX = 2025;
let year = YEAR_MIN;

// wms endpoints (https pra funcionar no github pages)
const WMS = {
  mapbiomas: "https://azure.solved.eco.br:8080/geoserver/solved/wms",
  terrabrasilis: "https://terrabrasilis.dpi.inpe.br/geoserver/ows",
  ibge: "https://geoservicos.ibge.gov.br/geoserver/ows"
};

// escolha automática de layer por getcapabilities (evita “nome errado”)
async function pickLayer(wmsUrl, preferRegexList){
  const url = wmsUrl + (wmsUrl.includes("?") ? "&" : "?") + "service=wms&request=getcapabilities&version=1.3.0&_=" + Date.now();
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error("getcapabilities falhou: " + wmsUrl);
  const xml = await res.text();
  const doc = new DOMParser().parseFromString(xml, "text/xml");
  const names = Array.from(doc.getElementsByTagName("Name")).map(n=>n.textContent||"").filter(Boolean);
  // remove “wms”/“ows” repetidos e pega só prováveis layers (contendo :)
  const layerNames = names.filter(n => n.includes(":") || n.length > 3);
  for(const rgx of preferRegexList){
    const hit = layerNames.find(n => rgx.test(n));
    if(hit) return hit;
  }
  // fallback: primeiro layer “provável”
  return layerNames.find(n=>n.includes(":")) || layerNames[layerNames.length-1];
}

let map, lyrVeg, lyrDef, lyrHyd;
let lyrVegName=null, lyrDefName=null, lyrHydName=null;

function initLeaflet(){
  map = L.map("leaflet", {
    zoomControl:false,
    attributionControl:false,
    worldCopyJump:true
  }).setView([-14.5, -55.5], 4);

  // fundo preto (sem tiles externos)
  const pane = map.getPane("tilePane");
  if(pane) pane.style.filter = "brightness(.9) contrast(1.05)";
}

// capitais (centros urbanos reais) para ping infinito
const capitais = [
  ["rio branco",-9.9754,-67.8249],["maceio",-9.6658,-35.7353],["macapa",0.0349,-51.0694],
  ["manaus",-3.1190,-60.0217],["salvador",-12.9714,-38.5014],["fortaleza",-3.7319,-38.5267],
  ["brasilia",-15.7939,-47.8828],["vitoria",-20.3155,-40.3128],["goiania",-16.6869,-49.2648],
  ["sao luis",-2.5307,-44.3068],["cuiaba",-15.6014,-56.0979],["campo grande",-20.4697,-54.6201],
  ["belo horizonte",-19.9167,-43.9345],["belem",-1.4558,-48.5039],["joao pessoa",-7.1195,-34.8450],
  ["curitiba",-25.4284,-49.2733],["recife",-8.0476,-34.8770],["teresina",-5.0919,-42.8034],
  ["rio de janeiro",-22.9068,-43.1729],["natal",-5.7793,-35.2009],["porto alegre",-30.0346,-51.2177],
  ["porto velho",-8.7608,-63.8999],["boa vista",2.8235,-60.6758],["florianopolis",-27.5949,-48.5482],
  ["sao paulo",-23.5505,-46.6333],["aracaju",-10.9472,-37.0731],["palmas",-10.1840,-48.3336]
];

// “ping” infinito: a cada frame, cria anéis que expandem e reiniciam
const ping = { red:[], blue:[] };
function spawnPing(list, lat, lng, kind){
  list.push({ lat, lng, r:0, a:1, kind });
}
function stepPings(dt){
  const speed = 180 * dt;      // px/s
  const fade  = 0.55 * dt;     // alpha/s
  for(const arr of [ping.red, ping.blue]){
    for(const p of arr){
      p.r += speed;
      p.a -= fade;
    }
    for(let i=arr.length-1;i>=0;i--){
      if(arr[i].a <= 0) arr.splice(i,1);
    }
  }
}
function drawPings(ctx){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  for(const p of ping.red){
    const pt = map.latLngToContainerPoint([p.lat,p.lng]);
    if(pt.x< -50 || pt.y< -50 || pt.x> w+50 || pt.y> h+50) continue;
    ctx.globalAlpha = Math.max(0, p.a);
    ctx.strokeStyle = "rgba(255,60,60,1)";
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, p.r, 0, Math.PI*2);
    ctx.stroke();
  }
  for(const p of ping.blue){
    const pt = map.latLngToContainerPoint([p.lat,p.lng]);
    if(pt.x< -50 || pt.y< -50 || pt.x> w+50 || pt.y> h+50) continue;
    ctx.globalAlpha = Math.max(0, p.a);
    ctx.strokeStyle = "rgba(60,160,255,1)";
    ctx.lineWidth = 1.1;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, p.r, 0, Math.PI*2);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function setWmsYear(layer, y){
  if(!layer) return;
  const yEff = y > 2024 ? 2024 : y; // 2025 ainda pode não existir em todos serviços
  layer.setParams({
    // TIME é padrão WMS para dimensão temporal (se o servidor suportar)
    time: `${yEff}-01-01`,
    // fallback comum em camadas do inpe/ibge: cql_filter
    cql_filter: `year=${yEff} OR ano=${yEff} OR anoref=${yEff}`,
    _: Date.now()
  });
}

async function ensureLayers(){
  if(!map) initLeaflet();

  // seleciona nomes uma vez
  if(!lyrVegName){
    try{
      lyrVegName = await pickLayer(WMS.mapbiomas, [
        /mapbiomas/i,
        /cobertura|lulc|land.?use|collection/i
      ]);
    }catch(e){
      console.warn("mapbiomas wms indisponível", e);
      lyrVegName = null;
    }
  }
  if(!lyrDefName){
    try{
      lyrDefName = await pickLayer(WMS.terrabrasilis, [
        /prodes.*(desmat|defor)/i,
        /(deter).*alert/i,
        /prodes/i,
        /deter/i
      ]);
    }catch(e){
      console.warn("terrabrasilis wms indisponível", e);
      lyrDefName = null;
    }
  }
  if(!lyrHydName){
    try{
      lyrHydName = await pickLayer(WMS.ibge, [
        /hidro|hidrograf/i,
        /rios|drenagem/i,
        /water/i
      ]);
    }catch(e){
      console.warn("ibge wms indisponível", e);
      lyrHydName = null;
    }
  }

  // cria layers wms (se tiver)
  if(lyrVegName && !lyrVeg){
    lyrVeg = L.tileLayer.wms(WMS.mapbiomas, {
      layers: lyrVegName,
      format: "image/png",
      transparent: true,
      opacity: 0.58
    }).addTo(map);
  }
  if(lyrDefName && !lyrDef){
    lyrDef = L.tileLayer.wms(WMS.terrabrasilis, {
      layers: lyrDefName,
      format: "image/png",
      transparent: true,
      opacity: 0.62
    }).addTo(map);
  }
  if(lyrHydName && !lyrHyd){
    lyrHyd = L.tileLayer.wms(WMS.ibge, {
      layers: lyrHydName,
      format: "image/png",
      transparent: true,
      opacity: 0.55
    }).addTo(map);
  }
}

function tickYear(){
  year++;
  if(year > YEAR_MAX) year = YEAR_MIN;

  // 2025: se serviços não tiverem, reaproveita 2024 e deixa explícito
  const shown = (year > 2024) ? 2024 : year;
  yearChip.textContent = `ano: ${year} ${year>2024 ? "(usando 2024)" : ""}`;

  setWmsYear(lyrVeg, year);
  setWmsYear(lyrDef, year);
  setWmsYear(lyrHyd, year);

  // pings infinitos (vermelho e azul)
  // vermelho: capitais sempre
  for(const c of capitais) spawnPing(ping.red, c[1], c[2], "red");

  // azul: 30 pings/ano em pontos pseudoaleatórios na amazônia legal (aprox bbox)
  for(let i=0;i<30;i++){
    const lat = -2 + (Math.random()*(-18+2));      // -2 a -18
    const lng = -44 + (Math.random()*(-30+44));    // -44 a -30
    spawnPing(ping.blue, lat, lng, "blue");
  }
}

// roda o loop quando tudo inicializar
let yearTimer=null;
async function startYearLoop(){
  try{
    await ensureLayers();
    if(yearTimer) clearInterval(yearTimer);
    year = YEAR_MIN;
    tickYear();
    yearTimer = setInterval(tickYear, 1000); // 1s por ano
  }catch(e){
    console.warn("loop de anos falhou", e);
  }
}

boot();
// inicia o loop de anos após o boot
setTimeout(()=>{ startYearLoop(); }, 600);

</script>

</body>
</html>
