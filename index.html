
<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNT — Centro Natural TEC Amazônia</title>

<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
  overflow:hidden;
}

#app{
  position:fixed; inset:0;
  display:grid;
  grid-template-columns: 300px 1fr 360px;
  grid-template-rows: 120px minmax(0,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:14px 16px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:8px;
}
#header h1{
  margin:0;
  font-size:26px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}

/* Left */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:56px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }

.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }

#status{
  margin-top:4px;
  font-size:10px;
  color:rgba(180,245,255,.9);
  opacity:.85;
  line-height:1.2;
}

/* Center */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.26;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.25), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.18), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.12), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
}
@keyframes glowPulse{
  0%{ opacity:.18; transform:scale(1); }
  50%{ opacity:.34; transform:scale(1.02); }
  100%{ opacity:.18; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.16;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }

.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }

#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
}

/* MOBILE REAL */
@media (max-width: 900px){
  html, body { overflow-x:hidden !important; overflow-y:auto; }
  #app{
    position:relative;
    inset:auto;
    min-height:100vh;
    grid-template-columns: 1fr;
    grid-template-rows: auto auto minmax(52vh, 60vh) auto;
    gap:12px;
    padding:12px;
  }
  #header{ grid-column:1/2; }
  #left{
    grid-column:1/2;
    max-height:42vh;
    overflow:auto;
  }
  #center{
    grid-column:1/2;
    height:56vh;
  }
  #right{ grid-column:1/2; }
}
</style>
</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — Centro Natural TEC Amazônia</h1>
    <p class="sub">Mapa ecológico real • Água (azul) • Vegetação (verde) • Transição (amarelo) • Desmatamento (vermelho)</p>
    <div id="chips">
      <div class="chip">Fonte: dados públicos governamentais</div>
      <div class="chip">Ano base: 2025</div>
      <div class="chip" id="chipPts">Pontos reais (sample → full)</div>
      <div class="chip">Compra: Pump.fun</div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

    <div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
    <div class="small">RAW auditável: <b id="raw">--</b></div>

    <div class="hr"></div>

    <div class="abclist">
      <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
      <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
      <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
      <div class="abcline"><b>Grau</b><span id="R">--</span></div>
    </div>

    <div class="hr"></div>

    <div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
    <div class="grid2">
      <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
      <div class="kv"><b>IAB</b><span id="iab">--</span></div>
      <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
      <div class="kv"><b>HID</b><span id="hid">--</span></div>
      <div class="kv"><b>ENT</b><span id="ent">--</span></div>
      <div class="kv"><b>PAN</b><span id="pan">--</span></div>
    </div>

    <div id="status">Status: carregando camadas…</div>
  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <canvas id="cnvBase" class="layer"></canvas>
      <canvas id="cnvOverlay" class="layer"></canvas>
      <canvas id="cnvHydro" class="layer"></canvas>
      <canvas id="cnvBorders" class="layer"></canvas>
      <canvas id="cnvPoints" class="layer"></canvas>
      <div id="mapGlow"></div>
      <div id="scanlines"></div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>
      <div class="mut">Abre o token no Pump.fun.</div>

      <label for="sol">Contribuição</label>
      <div class="row">
        <input id="sol" type="number" step="0.01" min="0" value="0.10" />
        <button class="btn" id="btnBuy">Comprar no Pump</button>
      </div>

      <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
      <div class="smallnote">Estimativa demo (não é cotação real).</div>
    </div>

    <div id="telemetry" class="glass">
      <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
      <canvas id="wave"></canvas>
      <div id="telemetryHint">Carregando…</div>
    </div>
  </div>
</div>

<script>
/* =========================
   BASE PATH (GitHub Pages OK)
========================= */
const BASE_PATH = location.hostname.includes("github.io")
  ? location.pathname.split("/").slice(0,2).join("/")
  : "";
const url = (f)=> (BASE_PATH ? (BASE_PATH + "/" + f) : ("./" + f));

/* =========================
   CONFIG
========================= */
const PUMP_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";

const FILES = {
  // geometria base (Brasil)
  br: ["BR_IBGE_simplificado.geojson","BR_IBGE.geojson"],
  // limites/recortes
  uf: ["uf.geojson"],
  // hidrografia
  macro: ["macro_rh.geojson"],
  micro: ["micro_rh.geojson"],
  // pontos
  ptsSample: ["vege_pts_sample.geojson"],
  ptsFull: ["vege_pts.geojson"],
  // legenda de pontos
  ptsLegend: ["layers_points.json"],
  // raster base
  baseImg: ["mapa_base.png"],
  prodesImg: ["prodes_mosaic.png"],
  // índice CNT
  cnt: ["CNT_FULL_10Y.geojson"]
};

const ECO_SCALE_MULT = 4;     // ECO/100 = cnt_A * 4
const rate = 147449130;       // demo SOL -> CNT

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
const chipPts = document.getElementById("chipPts");

function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

async function fetchJSON(u){
  const res = await fetch(u, { cache:"no-store" });
  if(!res.ok) throw new Error(`${u} HTTP ${res.status}`);
  return res.json();
}
async function fetchFirst(list){
  const errs=[];
  for(const f of list){
    try{ return {json: await fetchJSON(url(f)), file:f}; }
    catch(e){ errs.push(String(e.message||e)); }
  }
  throw new Error(errs.join(" | "));
}
async function fetchImage(file){
  const img = new Image();
  img.decoding="async";
  img.crossOrigin="anonymous";
  return new Promise((ok,fail)=>{
    img.onload=()=>ok(img);
    img.onerror=()=>fail(new Error("Falha ao carregar imagem: "+file));
    img.src = url(file) + "?v=" + Date.now();
  });
}

/* GEOJSON robusto */
function isGeomOK(g){ return g && (g.type==="Polygon" || g.type==="MultiPolygon"); }
function extractGeomsFromAny(obj){
  const out = [];
  if(!obj) return out;

  if(obj.type==="FeatureCollection" && Array.isArray(obj.features)){
    for(const f of obj.features){
      const g = f?.geometry;
      if(isGeomOK(g)) out.push(g);
      if(g?.type==="GeometryCollection" && Array.isArray(g.geometries)){
        for(const gg of g.geometries) if(isGeomOK(gg)) out.push(gg);
      }
    }
  } else if(obj.type==="Feature"){
    const g = obj.geometry;
    if(isGeomOK(g)) out.push(g);
    if(g?.type==="GeometryCollection" && Array.isArray(g.geometries)){
      for(const gg of g.geometries) if(isGeomOK(gg)) out.push(gg);
    }
  } else if(isGeomOK(obj)) out.push(obj);

  return out;
}
function mergeToMultiPolygon(geoms){
  const mp = { type:"MultiPolygon", coordinates: [] };
  for(const g of geoms){
    if(g.type==="Polygon") mp.coordinates.push(g.coordinates);
    else if(g.type==="MultiPolygon") mp.coordinates.push(...g.coordinates);
  }
  return mp;
}
function bboxFromCoords(coords){
  let minLon=+Infinity, minLat=+Infinity, maxLon=-Infinity, maxLat=-Infinity;
  const walk = (arr)=>{
    for(const v of arr){
      if(Array.isArray(v[0])) walk(v);
      else{
        const lon=v[0], lat=v[1];
        if(lon<minLon) minLon=lon;
        if(lat<minLat) minLat=lat;
        if(lon>maxLon) maxLon=lon;
        if(lat>maxLat) maxLat=lat;
      }
    }
  };
  walk(coords);
  return [minLon, minLat, maxLon, maxLat];
}
function projectFactory(bbox, W, H, pad=0.06){
  const [minLon, minLat, maxLon, maxLat] = bbox;
  const wLon = maxLon - minLon;
  const hLat = maxLat - minLat;
  const padX = W * pad, padY = H * pad;

  const sx = (W - padX*2) / wLon;
  const sy = (H - padY*2) / hLat;
  const s = Math.min(sx, sy);

  const drawW = wLon * s, drawH = hLat * s;
  const ox = (W - drawW)/2;
  const oy = (H - drawH)/2;

  return (lon, lat)=>[ ox + (lon - minLon)*s, oy + (maxLat - lat)*s ];
}

/* pontos dentro do Brasil */
function buildOuterRingsFromMultiPolygon(mp){
  const rings = [];
  for(const poly of mp.coordinates){
    if(Array.isArray(poly) && poly[0] && poly[0].length>3) rings.push(poly[0]);
  }
  return rings;
}
function pointInRing(pt, ring){
  let x=pt[0], y=pt[1], inside=false;
  for(let i=0,j=ring.length-1;i<ring.length;j=i++){
    const xi=ring[i][0], yi=ring[i][1];
    const xj=ring[j][0], yj=ring[j][1];
    const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi);
    if(intersect) inside = !inside;
  }
  return inside;
}
function pointInAnyOuterRing(lonlat, rings){
  for(const ring of rings) if(pointInRing(lonlat, ring)) return true;
  return false;
}

/* =========================
   CANVAS
========================= */
const cnvBase   = document.getElementById("cnvBase");
const cnvOverlay= document.getElementById("cnvOverlay");
const cnvHydro  = document.getElementById("cnvHydro");
const cnvBorders= document.getElementById("cnvBorders");
const cnvPoints = document.getElementById("cnvPoints");

const ctxBase = cnvBase.getContext("2d");
const ctxOv   = cnvOverlay.getContext("2d");
const ctxH    = cnvHydro.getContext("2d");
const ctxB    = cnvBorders.getContext("2d");
const ctxP    = cnvPoints.getContext("2d");

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const r = cnv.getBoundingClientRect();
  cnv.width  = Math.floor(r.width * dpr);
  cnv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function resizeAll(){
  resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvOverlay, ctxOv);
  resizeCanvas(cnvHydro, ctxH);
  resizeCanvas(cnvBorders, ctxB);
  resizeCanvas(cnvPoints, ctxP);
  resizeWave();
}
window.addEventListener("resize", ()=>{
  resizeAll();
  if(state.brGeom) redrawAll();
});

/* STATE */
const state = {
  brGeom:null,
  bbox:null,
  proj:null,
  outerRings:[],
  baseImg:null,
  prodesImg:null,
  uf:null,
  macro:null,
  micro:null,
  ptsLegend:null,
  pts:[],
  cntProps:null,
  series:[]
};

function clearAll(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctxBase.clearRect(0,0,W,H);
  ctxOv.clearRect(0,0,W,H);
  ctxH.clearRect(0,0,W,H);
  ctxB.clearRect(0,0,W,H);
  ctxP.clearRect(0,0,W,H);
}

/* =========================
   DRAW HELPERS
========================= */
function makePathFromMultiPolygon(ctx, mp){
  ctx.beginPath();
  for(const poly of mp.coordinates){
    const outer = poly[0];
    for(let i=0;i<outer.length;i++){
      const [x,y]=state.proj(outer[i][0], outer[i][1]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
  }
}

function drawRasterBase(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctxBase.clearRect(0,0,W,H);

  // fundo preto
  ctxBase.fillStyle = "rgba(0,0,0,1)";
  ctxBase.fillRect(0,0,W,H);

  // desenha imagem base cobrindo a área do canvas (estilo HUD)
  if(state.baseImg){
    ctxBase.save();
    ctxBase.globalAlpha = 0.88;
    ctxBase.imageSmoothingEnabled = true;

    // cover
    const img = state.baseImg;
    const scale = Math.max(W/img.width, H/img.height);
    const dw = img.width*scale;
    const dh = img.height*scale;
    const dx = (W - dw)/2;
    const dy = (H - dh)/2;
    ctxBase.drawImage(img, dx, dy, dw, dh);
    ctxBase.restore();
  }

  // recorta para dentro do Brasil (não vazar)
  ctxBase.save();
  makePathFromMultiPolygon(ctxBase, state.brGeom);
  ctxBase.globalCompositeOperation = "destination-in";
  ctxBase.fillStyle = "#fff";
  ctxBase.fill("evenodd");
  ctxBase.restore();
}

function drawProdesOverlay(){
  const W = cnvOverlay.getBoundingClientRect().width;
  const H = cnvOverlay.getBoundingClientRect().height;
  ctxOv.clearRect(0,0,W,H);

  if(!state.prodesImg) return;

  ctxOv.save();
  ctxOv.globalAlpha = 0.26;
  ctxOv.imageSmoothingEnabled = true;
  ctxOv.globalCompositeOperation = "screen";

  const img = state.prodesImg;
  const scale = Math.max(W/img.width, H/img.height);
  const dw = img.width*scale;
  const dh = img.height*scale;
  const dx = (W - dw)/2;
  const dy = (H - dh)/2;
  ctxOv.drawImage(img, dx, dy, dw, dh);

  // recorta dentro do Brasil
  makePathFromMultiPolygon(ctxOv, state.brGeom);
  ctxOv.globalCompositeOperation = "destination-in";
  ctxOv.fillStyle = "#fff";
  ctxOv.fill("evenodd");

  ctxOv.restore();
}

function drawBorders(){
  const W = cnvBorders.getBoundingClientRect().width;
  const H = cnvBorders.getBoundingClientRect().height;
  ctxB.clearRect(0,0,W,H);

  ctxB.save();
  ctxB.lineJoin="round"; ctxB.lineCap="round";

  // borda Brasil neon
  const strokeOnce = (w, col, blur, shadowCol)=>{
    ctxB.lineWidth = w;
    ctxB.strokeStyle = col;
    ctxB.shadowBlur = blur;
    ctxB.shadowColor = shadowCol;
    makePathFromMultiPolygon(ctxB, state.brGeom);
    ctxB.stroke();
  };
  strokeOnce(10, "rgba(120,220,255,0.18)", 18, "rgba(120,220,255,.65)");
  strokeOnce(3.2, "rgba(120,220,255,0.85)", 10, "rgba(120,220,255,.65)");

  // UF
  if(state.uf){
    ctxB.shadowBlur = 0;
    ctxB.lineWidth = 1.1;
    ctxB.strokeStyle = "rgba(140,240,255,0.42)";
    ctxB.beginPath();
    for(const f of state.uf.features || []){
      const g = f.geometry;
      if(!g) continue;
      const geoms = extractGeomsFromAny({type:"Feature", geometry:g});
      for(const gg of geoms){
        const mp = (gg.type==="Polygon") ? {type:"MultiPolygon",coordinates:[gg.coordinates]} :
                  (gg.type==="MultiPolygon" ? gg : null);
        if(!mp) continue;
        makePathFromMultiPolygon(ctxB, mp);
      }
    }
    ctxB.stroke();
  }

  ctxB.restore();
}

function drawHydro(){
  const W = cnvHydro.getBoundingClientRect().width;
  const H = cnvHydro.getBoundingClientRect().height;
  ctxH.clearRect(0,0,W,H);

  function strokeLineCollection(fc, alpha, w){
    if(!fc?.features) return;
    ctxH.save();
    ctxH.lineJoin="round"; ctxH.lineCap="round";
    ctxH.strokeStyle = `rgba(0,170,255,${alpha})`;
    ctxH.shadowColor = "rgba(0,170,255,0.7)";
    ctxH.shadowBlur = 10;
    ctxH.lineWidth = w;

    ctxH.beginPath();
    for(const f of fc.features){
      const g = f.geometry;
      if(!g) continue;

      const drawLine = (coords)=>{
        for(let i=0;i<coords.length;i++){
          const [x,y]=state.proj(coords[i][0], coords[i][1]);
          if(i===0) ctxH.moveTo(x,y); else ctxH.lineTo(x,y);
        }
      };

      if(g.type==="LineString"){
        drawLine(g.coordinates);
      }else if(g.type==="MultiLineString"){
        for(const ln of g.coordinates) drawLine(ln);
      }
    }
    ctxH.stroke();
    ctxH.restore();
  }

  // micro mais fino, macro mais brilhante
  strokeLineCollection(state.micro, 0.26, 0.9);
  strokeLineCollection(state.macro, 0.36, 1.6);

  // recorta no Brasil
  ctxH.save();
  makePathFromMultiPolygon(ctxH, state.brGeom);
  ctxH.globalCompositeOperation = "destination-in";
  ctxH.fillStyle = "#fff";
  ctxH.fill("evenodd");
  ctxH.restore();
}

/* =========================
   POINTS REAL (verde/amarelo/vermelho/azul)
========================= */
function parseLegendToMap(legendJson){
  // tenta entender qualquer formato de layers_points.json
  // objetivo: retornar {key -> {r,g,b, name}}
  const map = new Map();

  const add = (k, color, name)=>{
    if(!k) return;
    const c = String(color||"").replace("#","");
    let r=0,g=255,b=180;
    if(c.length===6){
      r=parseInt(c.slice(0,2),16);
      g=parseInt(c.slice(2,4),16);
      b=parseInt(c.slice(4,6),16);
    }
    map.set(String(k), {r,g,b, name:name||String(k)});
  };

  if(Array.isArray(legendJson)){
    for(const it of legendJson){
      add(it.id ?? it.value ?? it.key ?? it.code, it.color ?? it.hex ?? it.col, it.name ?? it.label);
    }
  } else if(legendJson && typeof legendJson==="object"){
    const arr = legendJson.layers || legendJson.items || legendJson.legend || legendJson.values;
    if(Array.isArray(arr)){
      for(const it of arr){
        add(it.id ?? it.value ?? it.key ?? it.code, it.color ?? it.hex ?? it.col, it.name ?? it.label);
      }
    } else {
      // caso seja dict {key:{color,name}}
      for(const [k,v] of Object.entries(legendJson)){
        if(v && typeof v==="object") add(k, v.color||v.hex, v.name||v.label);
      }
    }
  }

  // fallback padrão (se o json não tiver)
  if(map.size===0){
    map.set("agua", {r:0,g:170,b:255,name:"Água"});
    map.set("water",{r:0,g:170,b:255,name:"Água"});
    map.set("vegetacao",{r:60,g:255,b:140,name:"Vegetação"});
    map.set("veg",{r:60,g:255,b:140,name:"Vegetação"});
    map.set("transicao",{r:255,g:220,b:60,name:"Transição"});
    map.set("transition",{r:255,g:220,b:60,name:"Transição"});
    map.set("desmatamento",{r:255,g:80,b:60,name:"Desmatamento"});
    map.set("deforestation",{r:255,g:80,b:60,name:"Desmatamento"});
  }
  return map;
}

function detectClassKey(props){
  // tenta achar onde está a classe do ponto
  // exemplos comuns: class, classe, tipo, layer, label, id, code, value
  const keys = ["class","classe","tipo","layer","label","id","code","value","cat","categoria","name"];
  for(const k of keys){
    if(props && props[k] !== undefined && props[k] !== null) return k;
  }
  // tentativa por contains
  if(props){
    for(const k of Object.keys(props)){
      const lk = k.toLowerCase();
      if(lk.includes("class") || lk.includes("classe") || lk.includes("tipo") || lk.includes("layer")) return k;
    }
  }
  return null;
}

function buildPointObjects(geojson){
  const out = [];
  const feats = geojson?.features || [];
  for(const f of feats){
    const g = f.geometry;
    if(!g) continue;
    if(g.type==="Point"){
      const [lon,lat] = g.coordinates;
      out.push({lon,lat, props:f.properties||{}});
    } else if(g.type==="MultiPoint"){
      for(const c of g.coordinates){
        out.push({lon:c[0], lat:c[1], props:f.properties||{}});
      }
    }
  }
  return out;
}

function drawPoints(points, legendMap){
  const W = cnvPoints.getBoundingClientRect().width;
  const H = cnvPoints.getBoundingClientRect().height;
  ctxP.clearRect(0,0,W,H);

  const classKeyGuess = points[0]?.props ? detectClassKey(points[0].props) : null;

  // pontilhado fino
  const baseR = 1.05;         // tamanho mínimo do ponto
  const glowR = 3.4;          // halo
  const jitter = 0.35;

  let t = 0;
  const tick = ()=>{
    const W = cnvPoints.getBoundingClientRect().width;
    const H = cnvPoints.getBoundingClientRect().height;
    ctxP.clearRect(0,0,W,H);

    // leve densidade
    for(const p of points){
      const lon = p.lon, lat = p.lat;
      if(!pointInAnyOuterRing([lon,lat], state.outerRings)) continue;

      const [x0,y0] = state.proj(lon,lat);

      const props = p.props || {};
      const rawKey = classKeyGuess ? props[classKeyGuess] : (props.class ?? props.classe ?? props.tipo ?? props.layer);
      const key = (rawKey===undefined || rawKey===null) ? "" : String(rawKey);

      let col = legendMap.get(key);

      // heurística por texto (caso legend não bata)
      if(!col){
        const k = key.toLowerCase();
        if(k.includes("agua") || k.includes("water") || k==="91") col = {r:0,g:170,b:255,name:"Água"};
        else if(k.includes("desmat") || k.includes("defor") || k==="64") col = {r:255,g:90,b:60,name:"Desmatamento"};
        else if(k.includes("trans") || k.includes("past") || k.includes("agro") || k.includes("lavour") || k==="20") col = {r:255,g:220,b:60,name:"Transição"};
        else col = {r:60,g:255,b:140,name:"Vegetação"};
      }

      const pulse = 0.55 + 0.45*Math.sin((t*0.03) + (lon*0.7 + lat*0.9));
      const a = 0.10 + 0.28*pulse;

      const jx = Math.sin((t*0.02) + lon) * jitter;
      const jy = Math.cos((t*0.017) + lat) * jitter;

      // halo
      ctxP.beginPath();
      ctxP.fillStyle = `rgba(${col.r},${col.g},${col.b},${a*0.55})`;
      ctxP.arc(x0 + jx, y0 + jy, glowR, 0, Math.PI*2);
      ctxP.fill();

      // núcleo
      ctxP.beginPath();
      ctxP.fillStyle = `rgba(${col.r},${col.g},${col.b},${a+0.15})`;
      ctxP.arc(x0 + jx, y0 + jy, baseR, 0, Math.PI*2);
      ctxP.fill();
    }

    t++;
    requestAnimationFrame(tick);
  };

  tick();
}

/* =========================
   REDRAW
========================= */
function redrawAll(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  state.proj = projectFactory(state.bbox, W, H, 0.06);

  drawRasterBase();
  drawProdesOverlay();
  drawHydro();
  drawBorders();

  // se já temos pontos, redesenha (sem trocar animação)
}

/* =========================
   TELEMETRY
========================= */
const wave = document.getElementById("wave");
const wctx = wave.getContext("2d");
let tWave=0;
function resizeWave(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  wave.width = Math.floor(wave.clientWidth * dpr);
  wave.height = Math.floor(wave.clientHeight * dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0);
}
function startWave(){
  const draw = ()=>{
    const W = wave.clientWidth, H = wave.clientHeight;
    wctx.clearRect(0,0,W,H);
    wctx.fillStyle = "rgba(0,0,0,.25)";
    wctx.fillRect(0,0,W,H);

    wctx.strokeStyle = "rgba(110,210,255,.10)";
    wctx.lineWidth = 1;
    for(let y=12; y<H; y+=18){
      wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
    }

    const s = (state.series && state.series.length >= 2) ? state.series : null;
    const min = s ? Math.min(...s) : 0;
    const max = s ? Math.max(...s) : 1;

    function yAt(i){
      if(s){
        const idx = (i / (W-1)) * (s.length-1);
        const a = Math.floor(idx);
        const b = Math.min(s.length-1, a+1);
        const f = idx - a;
        const v = s[a]*(1-f) + s[b]*f;
        const norm = (max-min) < 1e-9 ? 0.5 : (v - min) / (max - min);
        let y = (H*0.18) + (1-norm) * (H*0.68);
        y += Math.sin((i + tWave)/28) * (H*0.02);
        return y;
      }
      return (H*0.52)
        + Math.sin((i+tWave)/38)*(H*0.20)
        + Math.sin((i+tWave)/13)*(H*0.07);
    }

    wctx.lineWidth = 2;
    wctx.strokeStyle = "rgba(110,210,255,.35)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    wctx.strokeStyle = "rgba(110,210,255,.90)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    tWave += 2;
    requestAnimationFrame(draw);
  };
  draw();
}

/* =========================
   BUY
========================= */
const solInput = document.getElementById("sol");
const out = document.getElementById("out");
function updateOut(){
  const sol = parseFloat(String(solInput.value).replace(",", ".")) || 0;
  out.textContent = (sol * rate).toLocaleString("pt-BR") + " CNT";
}
solInput.addEventListener("input", updateOut);
updateOut();

document.getElementById("btnBuy").addEventListener("click", ()=>{
  window.open(PUMP_URL, "_blank", "noopener,noreferrer");
});

/* =========================
   BOOT
========================= */
async function boot(){
  try{
    statusEl.textContent = "Status: carregando Brasil (IBGE)…";

    // Brasil base
    const brRes = await fetchFirst(FILES.br);
    const geoms = extractGeomsFromAny(brRes.json);
    if(!geoms.length) throw new Error("Brasil: GeoJSON sem Polygon/MultiPolygon.");
    state.brGeom = mergeToMultiPolygon(geoms);
    state.bbox = bboxFromCoords(state.brGeom.coordinates);
    state.outerRings = buildOuterRingsFromMultiPolygon(state.brGeom);

    // imagens (base + prodes)
    statusEl.textContent = "Status: carregando raster (mapa_base/prodes)…";
    try{ state.baseImg = await fetchImage(FILES.baseImg[0]); }catch(e){ state.baseImg=null; }
    try{ state.prodesImg = await fetchImage(FILES.prodesImg[0]); }catch(e){ state.prodesImg=null; }

    // camadas vetoriais
    statusEl.textContent = "Status: carregando UF + hidrografia…";
    try{ state.uf = (await fetchFirst(FILES.uf)).json; }catch(e){ state.uf=null; }
    try{ state.macro = (await fetchFirst(FILES.macro)).json; }catch(e){ state.macro=null; }
    try{ state.micro = (await fetchFirst(FILES.micro)).json; }catch(e){ state.micro=null; }

    // CNT painel
    statusEl.textContent = "Status: carregando CNT (índices)…";
    try{
      const cntRes = await fetchFirst(FILES.cnt);
      const props = cntRes.json?.features?.[0]?.properties;
      if(props){
        state.cntProps = props;

        const rawA = Number(props.cnt_A);
        const A100 = Number.isFinite(rawA) ? clamp(rawA * ECO_SCALE_MULT, 0, 100) : NaN;

        document.getElementById("raw").textContent = fmt(rawA,2);
        document.getElementById("eco").textContent = fmt1(A100);
        document.getElementById("A").textContent   = fmt(A100,2);

        const b = Number(props.cnt_B);
        document.getElementById("B").textContent = Number.isFinite(b) ? ((b>=0?"+":"") + fmt(b,2)) : "--";
        document.getElementById("C").textContent = fmt(props.cnt_C,2);
        document.getElementById("R").textContent = props.grade || "--";

        document.getElementById("ibe").textContent = Number.isFinite(Number(props.FUNC)) ? fmt(props.FUNC,1) : "--";
        document.getElementById("ibi").textContent = Number.isFinite(Number(props.IBI))  ? fmt(props.IBI,1)  : "--";
        document.getElementById("hid").textContent = Number.isFinite(Number(props.HID))  ? fmt(props.HID,2)  : "--";
        document.getElementById("ent").textContent = Number.isFinite(Number(props.ENT))  ? fmt(props.ENT,1)  : "--";
        document.getElementById("pan").textContent = Number.isFinite(Number(props.PAN))  ? fmt(props.PAN,1)  : "--";
        if(props.IAB !== null && props.IAB !== undefined && Number.isFinite(Number(props.IAB))){
          document.getElementById("iab").textContent = fmt(props.IAB,1);
        } else {
          document.getElementById("iab").textContent = "N/D";
        }

        state.series = Array.isArray(props.series_10y) ? props.series_10y.map(Number).filter(Number.isFinite) : [];
        document.getElementById("telemetryHint").textContent = state.series.length
          ? ("Histórico: " + state.series.length + " • Último (RAW): " + fmt(rawA,2))
          : "Sem série 10y no GeoJSON.";
      }
    }catch(e){
      // deixa vazio
      document.getElementById("telemetryHint").textContent = "CNT não carregou (ok).";
    }

    // legenda de pontos
    statusEl.textContent = "Status: carregando legenda de pontos…";
    let legendMap;
    try{
      const leg = await fetchFirst(FILES.ptsLegend);
      legendMap = parseLegendToMap(leg.json);
      state.ptsLegend = legendMap;
    }catch(e){
      legendMap = parseLegendToMap(null);
      state.ptsLegend = legendMap;
    }

    // resize + desenha base
    resizeAll();
    redrawAll();
    startWave();

    // pontos (sample rápido)
    statusEl.textContent = "Status: carregando pontos (sample)…";
    chipPts.textContent = "Pontos reais (sample → full)";

    const ptsSample = await fetchFirst(FILES.ptsSample);
    const pts1 = buildPointObjects(ptsSample.json);
    state.pts = pts1;

    // anima pontos sample
    drawPoints(state.pts, state.ptsLegend);

    statusEl.textContent = "Status: OK • sample carregado • tentando full…";

    // tenta FULL em background (sem travar mobile)
    fetchJSON(url(FILES.ptsFull[0]))
      .then(fullJson=>{
        const pts2 = buildPointObjects(fullJson);
        if(pts2 && pts2.length){
          state.pts = pts2;
          chipPts.textContent = "Pontos reais (FULL)";
          statusEl.textContent = "Status: OK • FULL carregado";
          // troca para full (mesma função, reinicia anima)
          drawPoints(state.pts, state.ptsLegend);
        }
      })
      .catch(()=>{
        chipPts.textContent = "Pontos reais (SAMPLE)";
        statusEl.textContent = "Status: OK • full não carregou (normal no celular).";
      });

  }catch(err){
    console.error(err);
    statusEl.textContent = "Status: ERRO • " + (err?.message || err);
    document.getElementById("telemetryHint").textContent = "Erro: camadas não carregaram. Veja o console (F12).";
    clearAll();
  }
}

boot();
</script>
</body>
</html>
