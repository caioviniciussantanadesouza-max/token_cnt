<script>
(() => {
  // ===== Config =====
  const TOKEN_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";
  const FILES = {
    baseImg: "mapa_base.png",
    mosaicImg: "prodes_mosaic.png",
    dados: "dados_cnt.json",
    // opcional (se tu tiver): "biomas.geojson"
    biomas: "biomas.geojson",
  };

  // ===== Helpers =====
  const $ = (id) => document.getElementById(id);
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  function detectBasePath(){
    // garante sempre /.../token_cnt/ (onde está o index.html)
    let p = location.pathname;
    if (p.endsWith("index.html")) p = p.slice(0, -"index.html".length);
    if (!p.endsWith("/")) p += "/";
    return location.origin + p;
  }

  function abs(base, file){ return base + file; }

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} em ${url}`);
    return r.json();
  }

  async function fetchJsonRetry(url, tries=3){
    let last;
    for (let i=0;i<tries;i++){
      try { return await fetchJson(url); }
      catch(e){ last=e; await new Promise(r=>setTimeout(r, 250*(i+1))); }
    }
    throw last;
  }

  function fmt2(v){
    if (v===null || v===undefined || Number.isNaN(v)) return "--";
    return (Math.round(v*100)/100).toString().replace(".",",");
  }

  // ===== UI =====
  const statusEl = $("status");
  const ptsHint = $("ptsHint");
  const basePathEl = $("basePath");

  $("buyBtn").addEventListener("click", () => {
    window.open(TOKEN_URL, "_blank", "noopener,noreferrer");
  });

  $("contrib").addEventListener("input", () => {
    const val = parseFloat(String($("contrib").value).replace(",","."));
    const est = (!Number.isFinite(val) || val<=0) ? 0 : Math.floor(val * 147449130);
    $("estCnt").textContent = est.toLocaleString("pt-BR");
  });
  $("contrib").dispatchEvent(new Event("input"));

  // ===== Telemetria =====
  function drawTelemetry(values){
    const c = $("telCanvas");
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = c.clientWidth, h = c.clientHeight;
    c.width = Math.floor(w * dpr);
    c.height = Math.floor(h * dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,w,h);
    if (!values || !values.length) return;

    const minV = Math.min(...values);
    const maxV = Math.max(...values);
    const pad = 14;
    const x0 = pad, y0 = pad;
    const x1 = w-pad, y1 = h-pad;
    const span = Math.max(1e-6, maxV-minV);

    const pts = values.map((v,i)=>{
      const t = values.length===1 ? 0 : i/(values.length-1);
      const x = x0 + t*(x1-x0);
      const y = y1 - ((v-minV)/span)*(y1-y0);
      return [x,y];
    });

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = "rgba(140,220,255,.95)";
    ctx.shadowColor = "rgba(110,210,255,.35)";
    ctx.shadowBlur = 10;
    ctx.beginPath();
    pts.forEach(([x,y],i)=> i?ctx.lineTo(x,y):ctx.moveTo(x,y));
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(200,243,255,.9)";
    for(const [x,y] of pts){
      ctx.beginPath();
      ctx.arc(x,y,2.2,0,Math.PI*2);
      ctx.fill();
    }
  }

  // ===== Map =====
  const baseCanvas = $("baseCanvas");
  const holoCanvas = $("holoCanvas");
  const mapWrap = $("mapWrap");

  function setMapAspectFromImage(img){
    const w = img.naturalWidth || 16;
    const h = img.naturalHeight || 9;
    mapWrap.style.aspectRatio = `${w} / ${h}`;
  }

  function resizeCanvasToWrap(c){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = mapWrap.clientWidth;
    const h = mapWrap.clientHeight;
    c.width = Math.floor(w * dpr);
    c.height = Math.floor(h * dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx, w, h};
  }

  async function loadImage(url){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=> resolve(img);
      img.onerror = ()=> reject(new Error("Falha ao carregar imagem: " + url));
      img.src = url;
    });
  }

  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h,s,l=(max+min)/2;
    if(max===min){h=s=0;}
    else{
      const d=max-min;
      s=l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return [h*360, s, l];
  }

  function classifyPixel(r,g,b){
    const [h,s,l] = rgbToHsl(r,g,b);
    if (l < 0.10) return null;
    if (h > 175 && h < 250 && s > 0.25) return "agua";
    if (h > 70 && h <= 170 && s > 0.18) return "veg";
    if (h >= 25 && h <= 70 && s > 0.18) return "trans";
    if ((h < 25 || h > 330) && s > 0.20) return "des";
    return "trans";
  }

  const CLASS_COL = {
    agua: [40, 170, 255],
    veg:  [0, 255, 170],
    trans:[255, 220, 0],
    des:  [255, 80, 80],
  };

  function buildPointsFromMosaic(mosaicImg, sampleStep=3, maxPoints=18000){
    const oc = document.createElement("canvas");
    oc.width = mosaicImg.naturalWidth;
    oc.height = mosaicImg.naturalHeight;
    const octx = oc.getContext("2d", {willReadFrequently:true});
    octx.drawImage(mosaicImg, 0,0);
    const imgData = octx.getImageData(0,0,oc.width,oc.height).data;

    const pts = [];
    for (let y=0; y<oc.height; y+=sampleStep){
      for (let x=0; x<oc.width; x+=sampleStep){
        const i = (y*oc.width + x) * 4;
        const r = imgData[i], g = imgData[i+1], b = imgData[i+2], a = imgData[i+3];
        if (a < 40) continue;
        const cls = classifyPixel(r,g,b);
        if (!cls) continue;
        const rx = x + (Math.random() - 0.5) * sampleStep;
        const ry = y + (Math.random() - 0.5) * sampleStep;
        pts.push({x: rx, y: ry, cls, seed: Math.random()});
      }
    }

    if (pts.length > maxPoints){
      const step = Math.ceil(pts.length / maxPoints);
      return pts.filter((_,i)=> i%step===0);
    }
    return pts;
  }

  function drawBase(baseImg){
    const {ctx,w,h} = resizeCanvasToWrap(baseCanvas);
    ctx.clearRect(0,0,w,h);
    ctx.globalAlpha = 0.96;
    ctx.drawImage(baseImg, 0,0,w,h);
  }

  function startHologram(points, mosaicNatural, state){
    let running = true;

    const groups = {
      agua: points.filter(p=>p.cls==="agua"),
      veg: points.filter(p=>p.cls==="veg"),
      trans: points.filter(p=>p.cls==="trans"),
      des: points.filter(p=>p.cls==="des"),
    };

    function render(t){
      if (!running) return;

      const {ctx,w,h} = resizeCanvasToWrap(holoCanvas);
      ctx.clearRect(0,0,w,h);

      const sx = w / mosaicNatural.w;
      const sy = h / mosaicNatural.h;

      const cnt = Number.isFinite(state.cntValue) ? state.cntValue : 50;
      const speed = 0.55 + (cnt/100)*1.65;
      const glow = 0.25 + (cnt/100)*0.45;
      const pulse = 0.55 + 0.45*Math.sin(t*0.001*speed);

      ctx.globalCompositeOperation = "lighter";

      for (const [cls, arr] of Object.entries(groups)){
        const col = CLASS_COL[cls] || [255,255,255];
        const baseA = cls==="des" ? 0.22 : cls==="agua" ? 0.18 : 0.20;
        const a = baseA + glow * 0.20;

        ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},${a})`;
        ctx.shadowColor = `rgba(${col[0]},${col[1]},${col[2]},${0.35 + glow*0.55})`;
        ctx.shadowBlur = 10 + glow*22;

        for (let i=0; i<arr.length; i++){
          const p = arr[i];
          const local = 0.6 + 0.4*Math.sin((t*0.001*speed) + p.seed*6.283);
          const r = (1.0 + 1.6*pulse*local) * (cls==="des" ? 1.15 : 1.0);

          const x = p.x*sx;
          const y = p.y*sy;
          if (x<0 || y<0 || x>w || y>h) continue;

          ctx.beginPath();
          ctx.arc(x,y,r,0,Math.PI*2);
          ctx.fill();
        }
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
    return () => { running = false; };
  }

  // ===== State =====
  const state = { cntValue: null, baseUrl: null };

  function applyDados(dados){
    $("yearPill").textContent = dados?.meta?.year ?? "2025";

    state.cntValue = Number(dados?.cnt?.value);
    $("cntValue").textContent = fmt2(state.cntValue);
    $("rawValue").textContent = fmt2(Number(dados?.cnt?.raw));

    $("aEstado").textContent = fmt2(Number(dados?.indices?.A_estado));
    $("bTend").textContent = fmt2(Number(dados?.indices?.B_tendencia));
    $("cEstab").textContent = fmt2(Number(dados?.indices?.C_estabilidade));
    $("grau").textContent = String(dados?.indices?.grau ?? "--");

    $("ibe").textContent = fmt2(Number(dados?.indices?.IBE));
    $("iab").textContent = String(dados?.indices?.IAB ?? "N/D");
    $("ibi").textContent = fmt2(Number(dados?.indices?.IBI));
    $("hid").textContent = fmt2(Number(dados?.indices?.HID));
    $("ent").textContent = fmt2(Number(dados?.indices?.ENT));
    $("pan").textContent = fmt2(Number(dados?.indices?.PAN));

    const serie = dados?.telemetry_10y || [];
    drawTelemetry(serie);
    $("telN").textContent = String(serie.length || 0);
    $("telLast").textContent = fmt2(serie.length ? serie[serie.length-1] : null);
  }

  async function init(){
    const base = detectBasePath();
    state.baseUrl = base;
    basePathEl.textContent = base;

    statusEl.textContent = "Status: carregando dados…";

    // >>> AQUI é a correção: sempre pelo basePath real
    const dadosUrl = abs(base, FILES.dados);

    const dados = await fetchJsonRetry(dadosUrl, 3);
    applyDados(dados);

    statusEl.textContent = "Status: carregando mapa…";

    const baseImg = await loadImage(abs(base, FILES.baseImg));
    const mosaicImg = await loadImage(abs(base, FILES.mosaicImg));

    setMapAspectFromImage(baseImg);
    drawBase(baseImg);

    const cacheKey = `cnt_pts_v2_${mosaicImg.naturalWidth}x${mosaicImg.naturalHeight}`;
    let points = null;
    try {
      const cached = localStorage.getItem(cacheKey);
      if (cached) points = JSON.parse(cached);
    } catch(_){}

    if (!points){
      statusEl.textContent = "Status: gerando holograma…";
      points = buildPointsFromMosaic(mosaicImg, 3, 18000);
      try { localStorage.setItem(cacheKey, JSON.stringify(points)); } catch(_){}
    }

    ptsHint.textContent = `Pontos: ${points.length.toLocaleString("pt-BR")}`;
    startHologram(points, {w:mosaicImg.naturalWidth, h:mosaicImg.naturalHeight}, state);

    statusEl.textContent = "Status: OK • Base e holograma alinhados • (cache local ativo)";

    let rto=null;
    window.addEventListener("resize", ()=>{
      clearTimeout(rto);
      rto=setTimeout(()=>{ drawBase(baseImg); }, 120);
    });
  }

  init().catch((err)=>{
    console.error(err);
    statusEl.textContent = "Status: ERRO — " + (err?.message || String(err));
  });
})();
</script>
