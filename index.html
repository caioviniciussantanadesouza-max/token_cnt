/* =========================
   MAPA 1 (holograma) — FIX REAL
   - remove fundo turquesa/branco
   - recorta automaticamente o conteúdo (sem margens)
   - desenha no mesmo tamanho do mapa base
========================= */
const holoOff = document.createElement("canvas");
const holoOffCtx = holoOff.getContext("2d", { willReadFrequently:true });

function isBgToRemove(r,g,b){
  // 1) branco / cinza muito claro
  const m = (r+g+b)/3;
  const v = Math.max(r,g,b) - Math.min(r,g,b);
  const isWhite = (r>225 && g>225 && b>225);
  const isLightGray = (m>215 && v<30);

  // 2) ciano/turquesa/azulado claro
  // regra bem agressiva: se G e B altos e R baixo ou médio, é fundo
  const cyan1 = (g > 130 && b > 130 && r < 140);
  const cyan2 = (b > 150 && g > 150 && r < 170);
  const cyan3 = ((g+b)/2 - r > 70 && Math.abs(g-b) < 90 && (g > 110 || b > 110));

  return isWhite || isLightGray || cyan1 || cyan2 || cyan3;
}

function computeAlphaBBox(imgData, W, H, alphaMin=8){
  const d = imgData.data;
  let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;

  for(let y=0; y<H; y++){
    for(let x=0; x<W; x++){
      const i = (y*W + x)*4;
      if(d[i+3] > alphaMin){
        if(x<minx) minx=x;
        if(y<miny) miny=y;
        if(x>maxx) maxx=x;
        if(y>maxy) maxy=y;
      }
    }
  }
  if(minx===Infinity) return null;
  return { minx, miny, maxx, maxy, w:(maxx-minx+1), h:(maxy-miny+1) };
}

function rebuildHoloKeyed(){
  const W = cnvHolo.getBoundingClientRect().width;
  const H = cnvHolo.getBoundingClientRect().height;

  state.holoKeyed = null;
  state.holoCrop = null;
  if(!state.holoImg || W<=1 || H<=1) return;

  holoOff.width = Math.max(1, Math.floor(W));
  holoOff.height = Math.max(1, Math.floor(H));
  holoOffCtx.clearRect(0,0,W,H);

  // desenha em "contain" (sem distorcer)
  const fit = fitContain(state.holoImg.naturalWidth, state.holoImg.naturalHeight, W, H);
  holoOffCtx.drawImage(state.holoImg, fit.x, fit.y, fit.w, fit.h);

  // remove fundo turquesa/branco
  const imgData = holoOffCtx.getImageData(0,0,W,H);
  const d = imgData.data;

  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    if(isBgToRemove(r,g,b)){
      d[i+3] = 0; // TRANSPARENTE
    }else{
      // reforço leve de alpha nos pixels do mapa (mantém sem “pintar fundo”)
      d[i+3] = Math.min(255, d[i+3] + 10);
    }
  }
  holoOffCtx.putImageData(imgData,0,0);

  // calcula recorte automático do conteúdo (remove margens)
  const crop = computeAlphaBBox(imgData, W, H, 10);
  state.holoKeyed = holoOff;
  state.holoCrop = crop; // {minx,miny,w,h}
}

function drawHologram(){
  const W = cnvHolo.getBoundingClientRect().width;
  const H = cnvHolo.getBoundingClientRect().height;

  ctxH.clearRect(0,0,W,H);
  if(!state.holoKeyed || !state.holoCrop) return;

  // “suspenso” (bem sutil)
  const hover = Math.sin(state.t/42) * 1.6;
  const dx = 0.0;
  const dy = -2.0 + hover;

  const c = state.holoCrop;

  ctxH.save();

  // desenha só o recorte do mapa 1 esticado para o canvas inteiro
  // (isso garante mesmo tamanho do mapa base)
  ctxH.globalCompositeOperation = "screen";
  ctxH.globalAlpha = 0.78;

  ctxH.translate(dx, dy);

  // glow leve
  ctxH.shadowBlur = 22;
  ctxH.shadowColor = "rgba(0,255,220,0.65)";
  ctxH.drawImage(state.holoKeyed, c.minx, c.miny, c.w, c.h, 0, 0, W, H);

  ctxH.shadowBlur = 10;
  ctxH.shadowColor = "rgba(0,255,255,0.35)";
  ctxH.drawImage(state.holoKeyed, c.minx, c.miny, c.w, c.h, 0, 0, W, H);

  ctxH.restore();

  // recorta no Brasil (pra ficar em cima do mapa 2 certinho)
  maskCanvasToBrasil(ctxH);
}
