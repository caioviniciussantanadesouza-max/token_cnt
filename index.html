<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNT — Centro Natural TEC Amazônia</title>

<!-- FIX: tudo relativo ao próprio index dentro de /token_cnt/ -->
<base href="./" />

<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
  overflow:hidden;
}

#app{
  position:fixed; inset:0;
  display:grid;
  grid-template-columns: 300px 1fr 360px;
  grid-template-rows: 120px minmax(0,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:14px 16px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:8px;
}
#header h1{
  margin:0;
  font-size:26px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}
.chip strong{ color:#e9fdff; }
.chipBtn{
  cursor:pointer;
  user-select:none;
}
.chipBtn:hover{
  box-shadow:0 0 18px rgba(110,210,255,.18);
}

/* Left */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:56px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }

.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }

#status{
  margin-top:4px;
  font-size:10px;
  color:rgba(180,245,255,.9);
  opacity:.85;
  line-height:1.2;
}

/* Center */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.26;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.25), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.18), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.12), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
}
@keyframes glowPulse{
  0%{ opacity:.18; transform:scale(1); }
  50%{ opacity:.34; transform:scale(1.02); }
  100%{ opacity:.18; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.16;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

#mapMsg{
  position:absolute;
  left:12px; bottom:12px;
  font-size:11px;
  color:rgba(160,240,255,.9);
  opacity:.9;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(110,210,255,.14);
  background: rgba(0,0,0,.22);
}

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }

.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }

#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
}

/* Responsive */
@media (max-width: 1100px){
  body{ overflow:auto; }
  #app{
    position:relative;
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto auto;
  }
  #center{ height:48vh; }
}
</style>
</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — Centro Natural TEC Amazônia</h1>
    <p class="sub">Monitoramento ambiental integrado • IBGE + PRODES/DETER + MapBiomas</p>
    <div id="chips">
      <div class="chip" id="chipFonte">Fonte: dados públicos governamentais</div>
      <div class="chip" id="chipAno">Ano base: <strong id="anoBase">2025</strong></div>
      <div class="chip chipBtn" id="chipRebuild">Regerar holograma</div>
      <div class="chip">Água <strong style="color:#68c6ff;">■</strong> Veg <strong style="color:#00ffb8;">■</strong> Trans <strong style="color:#ffe05a;">■</strong> Desm <strong style="color:#ff6a6a;">■</strong></div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

    <div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
    <div class="small">RAW auditável: <b id="raw">--</b></div>

    <div class="hr"></div>

    <div class="abclist">
      <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
      <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
      <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
      <div class="abcline"><b>Grau</b><span id="R">--</span></div>
    </div>

    <div class="hr"></div>

    <div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
    <div class="grid2">
      <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
      <div class="kv"><b>IAB</b><span id="iab">--</span></div>
      <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
      <div class="kv"><b>HID</b><span id="hid">--</span></div>
      <div class="kv"><b>ENT</b><span id="ent">--</span></div>
      <div class="kv"><b>PAN</b><span id="pan">--</span></div>
    </div>

    <div id="status">Status: carregando…</div>
  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <canvas id="cnvBase" class="layer"></canvas>
      <canvas id="cnvHolo" class="layer"></canvas>
      <canvas id="cnvBorder" class="layer"></canvas>
      <div id="mapGlow"></div>
      <div id="scanlines"></div>
      <div id="mapMsg">Inicializando…</div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>

      <label for="sol">Contribuição</label>
      <div class="row">
        <input id="sol" type="number" step="0.01" min="0" value="0.10" />
        <button class="btn" id="btnBuy">Comprar no Pump</button>
      </div>

      <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
      <div class="smallnote">Abre uma nova aba com o token no Pump.fun.</div>
    </div>

    <div id="telemetry" class="glass">
      <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
      <canvas id="wave"></canvas>
      <div id="telemetryHint">Carregando…</div>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const PUMP_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";
const FILES = {
  dados: "dados_cnt.json",
  baseImg: "mapa_base.png",
  mosaicImg: "prodes_mosaic.png",
  br: "BR_IBGE_simplificado.geojson"
};
const rate = 147449130;
const CACHE_KEY = "CNT_HOLO_POINTS_V1";

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
const mapMsg = document.getElementById("mapMsg");
function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

async function fetchJSON(file){
  const res = await fetch(file, { cache:"no-store" });
  if(!res.ok) throw new Error(`${file} HTTP ${res.status}`);
  return res.json();
}

function loadImage(file){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.decoding = "async";
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error("Falha ao carregar imagem: " + file));
    img.src = file;
  });
}

/* =========================
   CANVAS SETUP
========================= */
const cnvBase  = document.getElementById("cnvBase");
const cnvHolo  = document.getElementById("cnvHolo");
const cnvBorder= document.getElementById("cnvBorder");
const ctxBase = cnvBase.getContext("2d", {alpha:true, desynchronized:true});
const ctxHolo = cnvHolo.getContext("2d", {alpha:true, desynchronized:true});
const ctxBorder = cnvBorder.getContext("2d", {alpha:true, desynchronized:true});

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const r = cnv.getBoundingClientRect();
  cnv.width  = Math.floor(r.width * dpr);
  cnv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {w:r.width, h:r.height};
}
let VIEW = {w:0,h:0};

window.addEventListener("resize", ()=>{
  VIEW = resizeAll();
  drawBaseAndBorder();
}, {passive:true});

function resizeAll(){
  const a = resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvHolo, ctxHolo);
  resizeCanvas(cnvBorder, ctxBorder);
  resizeWave();
  return {w:a.w, h:a.h};
}

/* =========================
   DRAW BASE (contain rect)
========================= */
let baseImg=null, mosaicImg=null, brGeo=null;
let containRect=null; // {dx,dy,dw,dh, s}

function drawContain(ctx, img, W, H, alpha=1){
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  const s = Math.min(W/iw, H/ih);
  const dw = iw*s, dh = ih*s;
  const dx = (W-dw)/2, dy = (H-dh)/2;
  ctx.globalAlpha = alpha;
  ctx.drawImage(img, dx, dy, dw, dh);
  return {dx,dy,dw,dh,s,iw,ih};
}

function makePathFromGeo(ctx, geo, proj){
  ctx.beginPath();
  const feats = geo.type==="FeatureCollection" ? geo.features : [];
  for(const f of feats){
    const g = f.geometry;
    if(!g) continue;
    const drawRing = (ring)=>{
      for(let i=0;i<ring.length;i++){
        const [lon,lat]=ring[i];
        const [x,y]=proj(lon,lat);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.closePath();
    };
    if(g.type==="Polygon"){
      for(const ring of g.coordinates) drawRing(ring);
    }else if(g.type==="MultiPolygon"){
      for(const poly of g.coordinates) for(const ring of poly) drawRing(ring);
    }
  }
}

function bboxOfGeoJSON(geo){
  let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
  function scan(c){
    if(typeof c[0]==="number"){
      const x=c[0], y=c[1];
      if(x<minX) minX=x; if(x>maxX) maxX=x;
      if(y<minY) minY=y; if(y>maxY) maxY=y;
      return;
    }
    for(const k of c) scan(k);
  }
  for(const f of geo.features) scan(f.geometry.coordinates);
  return {minX,minY,maxX,maxY};
}
function projectFactory(bbox, W, H, pad=0.07){
  const dx=bbox.maxX-bbox.minX, dy=bbox.maxY-bbox.minY;
  const usableW=W*(1-pad*2), usableH=H*(1-pad*2);
  const s = Math.min(usableW/dx, usableH/dy);
  const cx=(bbox.minX+bbox.maxX)/2;
  const cy=(bbox.minY+bbox.maxY)/2;
  return (lon,lat)=>[ (lon-cx)*s + W/2, (-(lat-cy))*s + H/2 ];
}
let PROJ=null;

function drawBaseAndBorder(){
  if(!baseImg || !mosaicImg || !brGeo) return;
  const W = VIEW.w, H = VIEW.h;

  ctxBase.clearRect(0,0,W,H);
  ctxBorder.clearRect(0,0,W,H);

  // base + mosaic sutil (mesmo contain)
  containRect = drawContain(ctxBase, baseImg, W, H, 0.92);
  drawContain(ctxBase, mosaicImg, W, H, 0.18);

  // borda neon via geojson (não precisa alinhar com a imagem; é “HUD”)
  const bbox = bboxOfGeoJSON(brGeo);
  PROJ = projectFactory(bbox, W, H, 0.07);

  ctxBorder.save();
  ctxBorder.lineJoin="round"; ctxBorder.lineCap="round";
  ctxBorder.shadowBlur = 18;
  ctxBorder.shadowColor = "rgba(110,210,255,.35)";
  ctxBorder.strokeStyle = "rgba(110,210,255,.78)";
  ctxBorder.lineWidth = 2.2;
  makePathFromGeo(ctxBorder, brGeo, PROJ);
  ctxBorder.stroke();
  ctxBorder.restore();
}

/* =========================
   HOLOGRAM POINTS FROM MOSAIC (REAL)
   - usa prodes_mosaic + máscara do mapa_base
   - fica 100% dentro do mapa da imagem
========================= */
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){h=s=0;}
  else{
    const d=max-min;
    s=l>0.5? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  return [h*360,s,l];
}
function classifyPixel(r,g,b, luma){
  // luma já filtrou "fora"
  const [h,s,l] = rgbToHsl(r,g,b);
  if(l < 0.08) return null;

  // azul (água)
  if(h > 175 && h < 250 && s > 0.18) return "agua";
  // verde (veg)
  if(h > 70 && h <= 170 && s > 0.12) return "veg";
  // amarelo (transição)
  if(h >= 25 && h <= 70 && s > 0.10) return "trans";
  // vermelho (desmatamento)
  if((h < 20 || h > 330) && s > 0.12) return "des";

  // fallback (trans)
  return "trans";
}

const COL = {
  agua: [90,190,255],
  veg:  [0,255,184],
  trans:[255,226,90],
  des:  [255,106,106]
};

function buildPointsFromImages(baseImg, mosaicImg){
  // downscale p/ ser rápido
  const targetW = 720;
  const iw = mosaicImg.naturalWidth, ih = mosaicImg.naturalHeight;
  const s = targetW / iw;
  const w = Math.max(200, Math.round(iw*s));
  const h = Math.max(200, Math.round(ih*s));

  const cBase = document.createElement("canvas");
  const cM = document.createElement("canvas");
  cBase.width=w; cBase.height=h;
  cM.width=w; cM.height=h;
  const bctx=cBase.getContext("2d", {willReadFrequently:true});
  const mctx=cM.getContext("2d", {willReadFrequently:true});
  bctx.drawImage(baseImg, 0,0,w,h);
  mctx.drawImage(mosaicImg,0,0,w,h);

  const bd = bctx.getImageData(0,0,w,h).data;
  const md = mctx.getImageData(0,0,w,h).data;

  // gera pontos
  const pts = [];
  const step = 2; // densidade
  for(let y=0;y<h;y+=step){
    for(let x=0;x<w;x+=step){
      const i=(y*w+x)*4;
      const br=bd[i], bg=bd[i+1], bb=bd[i+2], ba=bd[i+3];
      const lumaBase = (0.2126*br + 0.7152*bg + 0.0722*bb);
      // máscara: fora do mapa base é quase preto
      if(ba < 30 || lumaBase < 12) continue;

      const r=md[i], g=md[i+1], b=md[i+2], a=md[i+3];
      if(a<30) continue;

      const luma = (0.2126*r + 0.7152*g + 0.0722*b);
      if(luma < 10) continue;

      const cls = classifyPixel(r,g,b,luma);
      if(!cls) continue;

      // guarda normalizado (0..1 dentro da imagem downscale)
      pts.push({
        u: x / w,
        v: y / h,
        cls,
        seed: ((x*73856093) ^ (y*19349663)) >>> 0
      });
    }
  }
  return pts;
}

function loadCachedPoints(){
  try{
    const raw = localStorage.getItem(CACHE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj || !Array.isArray(obj.pts) || !obj.pts.length) return null;
    return obj.pts;
  }catch(e){ return null; }
}
function saveCachedPoints(pts){
  try{
    localStorage.setItem(CACHE_KEY, JSON.stringify({pts, at: Date.now()}));
  }catch(e){}
}

let POINTS = [];
let tP=0;
let intensityK = 1.0;

function drawHologram(){
  const W = VIEW.w, H = VIEW.h;
  ctxHolo.clearRect(0,0,W,H);
  if(!containRect || !POINTS.length) return;

  // pontos desenhados dentro do containRect (mesmo tamanho do mapa base)
  const {dx,dy,dw,dh} = containRect;

  // pulsação ligada ao índice real
  const pulse = 0.55 + 0.45*Math.sin(tP*0.020);
  const alphaBase = 0.10 + 0.30*pulse*intensityK;

  ctxHolo.globalCompositeOperation = "lighter";

  for(let i=0;i<POINTS.length;i++){
    const p = POINTS[i];
    const c = COL[p.cls] || [200,245,255];

    const x = dx + p.u * dw;
    const y = dy + p.v * dh;

    const local = 0.65 + 0.35*Math.sin((tP*0.018) + (p.seed % 997)/120);
    const a = alphaBase * local;

    const size = 0.55 + 1.35*local;

    ctxHolo.shadowBlur = 10;
    ctxHolo.shadowColor = `rgba(${c[0]},${c[1]},${c[2]},${0.45*a})`;
    ctxHolo.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a})`;

    ctxHolo.beginPath();
    ctxHolo.arc(x, y, size, 0, Math.PI*2);
    ctxHolo.fill();
  }

  // micro “faíscas”
  for(let k=0;k<14;k++){
    const p = POINTS[(Math.random()*POINTS.length)|0];
    const c = COL[p.cls] || [200,245,255];
    const x = dx + p.u * dw;
    const y = dy + p.v * dh;
    ctxHolo.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},0.10)`;
    ctxHolo.lineWidth = 1;
    ctxHolo.beginPath();
    ctxHolo.moveTo(x, y);
    ctxHolo.lineTo(x + (Math.random()*18-9), y + (Math.random()*18-9));
    ctxHolo.stroke();
  }

  ctxHolo.globalCompositeOperation = "source-over";
  tP++;
  requestAnimationFrame(drawHologram);
}

/* =========================
   TELEMETRY
========================= */
const wave = document.getElementById("wave");
const wctx = wave.getContext("2d");
let tWave=0;
function resizeWave(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  wave.width = Math.floor(wave.clientWidth * dpr);
  wave.height = Math.floor(wave.clientHeight * dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0);
}
function startWave(series){
  const s = Array.isArray(series) ? series.map(Number).filter(Number.isFinite) : [];
  const min = s.length ? Math.min(...s) : 0;
  const max = s.length ? Math.max(...s) : 1;

  const draw = ()=>{
    const W = wave.clientWidth, H = wave.clientHeight;
    wctx.clearRect(0,0,W,H);

    wctx.fillStyle = "rgba(0,0,0,.25)";
    wctx.fillRect(0,0,W,H);

    wctx.strokeStyle = "rgba(110,210,255,.10)";
    wctx.lineWidth = 1;
    for(let y=12; y<H; y+=18){
      wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
    }

    function yAt(i){
      if(s.length>=2){
        const idx = (i / (W-1)) * (s.length-1);
        const a = Math.floor(idx);
        const b = Math.min(s.length-1, a+1);
        const f = idx - a;
        const v = s[a]*(1-f) + s[b]*f;
        const norm = (max-min) < 1e-9 ? 0.5 : (v - min) / (max - min);
        let y = (H*0.18) + (1-norm) * (H*0.68);
        y += Math.sin((i + tWave)/28) * (H*0.02);
        return y;
      }
      return (H*0.52)
        + Math.sin((i+tWave)/38)*(H*0.20)
        + Math.sin((i+tWave)/13)*(H*0.07);
    }

    wctx.lineWidth = 2;
    wctx.strokeStyle = "rgba(110,210,255,.35)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    wctx.strokeStyle = "rgba(110,210,255,.90)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    tWave += 2;
    requestAnimationFrame(draw);
  };
  draw();
}

/* =========================
   BUY
========================= */
const solInput = document.getElementById("sol");
const out = document.getElementById("out");
function updateOut(){
  const sol = parseFloat(solInput.value) || 0;
  out.textContent = (sol * rate).toLocaleString("pt-BR") + " CNT";
}
solInput.addEventListener("input", updateOut);
updateOut();

document.getElementById("btnBuy").addEventListener("click", ()=>{
  window.open(PUMP_URL, "_blank", "noopener,noreferrer");
});

/* =========================
   BOOT
========================= */
async function boot(){
  try{
    statusEl.textContent = "Status: carregando dados_cnt…";
    mapMsg.textContent = "Carregando…";

    const dados = await fetchJSON(FILES.dados);

    // painel
    const A = Number(dados?.cnt?.A);
    const B = Number(dados?.cnt?.B);
    const C = Number(dados?.cnt?.C);
    const rating = dados?.cnt?.rating || "--";

    const rawLast = (dados?.telemetry_10y && dados.telemetry_10y.length)
      ? Number(dados.telemetry_10y[dados.telemetry_10y.length-1])
      : NaN;

    // intensidade do holograma (real)
    // A (0..100) + RAW (0..~20) -> 0.7..1.6
    intensityK = clamp(0.70 + (isFinite(A)?A:50)/140 + (isFinite(rawLast)?rawLast:10)/60, 0.7, 1.7);

    document.getElementById("raw").textContent = fmt(rawLast,2);
    document.getElementById("eco").textContent = isFinite(A) ? fmt1(A) : "--";

    document.getElementById("A").textContent = isFinite(A) ? fmt(A,2) : "--";
    document.getElementById("B").textContent = isFinite(B) ? ((B>=0?"+":"") + fmt(B,2)) : "--";
    document.getElementById("C").textContent = isFinite(C) ? fmt(C,2) : "--";
    document.getElementById("R").textContent = rating;

    const idx = dados?.indices || {};
    document.getElementById("ibe").textContent = (idx.IBE!=null && isFinite(Number(idx.IBE))) ? fmt(idx.IBE,1) : "--";
    document.getElementById("iab").textContent = (idx.IAB!=null && isFinite(Number(idx.IAB))) ? fmt(idx.IAB,1) : "N/D";
    document.getElementById("ibi").textContent = (idx.IBI!=null && isFinite(Number(idx.IBI))) ? fmt(idx.IBI,1) : "--";
    document.getElementById("hid").textContent = (idx.HID!=null && isFinite(Number(idx.HID))) ? fmt(idx.HID,2) : "--";
    document.getElementById("ent").textContent = (idx.ENT!=null && isFinite(Number(idx.ENT))) ? fmt(idx.ENT,1) : "--";
    document.getElementById("pan").textContent = (idx.PAN!=null && isFinite(Number(idx.PAN))) ? fmt(idx.PAN,1) : "--";

    // telemetria
    const series = Array.isArray(dados?.telemetry_10y) ? dados.telemetry_10y : [];
    document.getElementById("telemetryHint").textContent =
      series.length ? ("Histórico: " + series.length + " • Último (RAW): " + fmt(rawLast,2)) : "Sem telemetria.";
    resizeAll();
    startWave(series);

    statusEl.textContent = "Status: carregando imagens…";

    // assets
    [baseImg, mosaicImg, brGeo] = await Promise.all([
      loadImage(FILES.baseImg),
      loadImage(FILES.mosaicImg),
      fetchJSON(FILES.br)
    ]);

    VIEW = resizeAll();
    drawBaseAndBorder();

    // pontos do holograma (cache)
    mapMsg.textContent = "Gerando holograma…";
    const cached = loadCachedPoints();
    if(cached){
      POINTS = cached;
      mapMsg.textContent = "Holograma (cache) • Pontos: " + POINTS.length.toLocaleString("pt-BR");
    }else{
      POINTS = buildPointsFromImages(baseImg, mosaicImg);
      saveCachedPoints(POINTS);
      mapMsg.textContent = "Holograma real • Pontos: " + POINTS.length.toLocaleString("pt-BR");
    }

    // botão “regerar” (limpa cache)
    document.getElementById("chipRebuild").addEventListener("click", ()=>{
      try{ localStorage.removeItem(CACHE_KEY); }catch(e){}
      mapMsg.textContent = "Regerando…";
      POINTS = buildPointsFromImages(baseImg, mosaicImg);
      saveCachedPoints(POINTS);
      mapMsg.textContent = "Regerado • Pontos: " + POINTS.length.toLocaleString("pt-BR");
    });

    statusEl.textContent = "Status: OK • holograma alinhado ao mapa base.";
    requestAnimationFrame(drawHologram);

  }catch(err){
    console.error(err);
    statusEl.textContent = "Status: ERRO • " + (err?.message || err);
    mapMsg.textContent = "ERRO: " + (err?.message || err);

    // caixa na tela (celular)
    const div = document.createElement("div");
    div.style.cssText = "position:fixed;left:14px;right:14px;bottom:14px;z-index:99999;padding:12px 14px;border-radius:14px;background:rgba(255,80,80,.10);border:1px solid rgba(255,80,80,.35);color:#ffdede;font:12px/1.35 system-ui;";
    div.textContent = "ERRO: " + (err?.message || String(err)) + " — confira se os arquivos estão na mesma pasta do index.";
    document.body.appendChild(div);
  }
}
boot();
</script>
</body>
</html>
