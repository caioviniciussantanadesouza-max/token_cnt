<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>CNT — Centro Natural TEC Amazônia</title>

<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --hud: rgba(110,210,255,.95);
  --hud2: rgba(110,210,255,.55);
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
}

/* APP GRID (desktop) */
#app{
  min-height:100vh;
  display:grid;
  grid-template-columns: 320px 1fr 360px;
  grid-template-rows: 140px minmax(520px,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:16px 16px 14px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:10px;
}
#header h1{
  margin:0;
  font-size:30px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:13px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}

/* Left (indices) */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:58px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:8px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }

.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:8px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }
#status{
  margin-top:6px;
  font-size:10px;
  color:rgba(180,245,255,.9);
  opacity:.85;
  line-height:1.2;
}

/* Center (map) */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.22;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.25), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.18), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.12), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
}
@keyframes glowPulse{
  0%{ opacity:.16; transform:scale(1); }
  50%{ opacity:.28; transform:scale(1.02); }
  100%{ opacity:.16; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

#mapMsg{
  position:absolute;
  left:14px; top:12px;
  font-size:12px;
  color:#bdf4ff;
  opacity:.9;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(110,210,255,.16);
  background:rgba(0,0,0,.26);
}

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }
.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }

#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
}

/* Mobile layout: map first, then BUY+telemetry, then indices */
@media (max-width: 980px){
  body{ overflow:auto; }
  #app{
    grid-template-columns: 1fr;
    grid-template-rows: auto 52vh auto auto auto;
    grid-template-areas:
      "header"
      "center"
      "buy"
      "telemetry"
      "left";
  }
  #header{ grid-area: header; }
  #center{ grid-area: center; min-height:52vh; }
  #left{ grid-area: left; }
  #buy{ grid-area: buy; }
  #telemetry{ grid-area: telemetry; }
  #right{ display:contents; }
  input{ width:100%; }
  .btn{ width:100%; }
}
</style>
</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — Centro Natural TEC Amazônia</h1>
    <p class="sub">Mapa ecológico real • Água (azul) • Vegetação (verde) • Transição (amarelo) • Desmatamento (vermelho)</p>
    <div id="chips">
      <div class="chip">Fonte: dados públicos governamentais</div>
      <div class="chip">Ano base: 2025</div>
      <div class="chip">Pontos reais (PRODES/MapBiomas)</div>
      <div class="chip">Compra: Pump.fun</div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

    <div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
    <div class="small">RAW auditável: <b id="raw">--</b></div>

    <div class="hr"></div>

    <div class="abclist">
      <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
      <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
      <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
      <div class="abcline"><b>Grau</b><span id="R">--</span></div>
    </div>

    <div class="hr"></div>

    <div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
    <div class="grid2">
      <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
      <div class="kv"><b>IAB</b><span id="iab">--</span></div>
      <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
      <div class="kv"><b>HID</b><span id="hid">--</span></div>
      <div class="kv"><b>ENT</b><span id="ent">--</span></div>
      <div class="kv"><b>PAN</b><span id="pan">--</span></div>
    </div>

    <div id="status">Status: iniciando…</div>
  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <canvas id="cnvBase" class="layer"></canvas>
      <canvas id="cnvHydro" class="layer"></canvas>
      <canvas id="cnvBorder" class="layer"></canvas>
      <canvas id="cnvPoints" class="layer"></canvas>
      <div id="mapGlow"></div>
      <div id="scanlines"></div>
      <div id="mapMsg">Carregando camadas…</div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>
      <p class="mut">Abre o token no Pump.fun.</p>

      <label for="sol">Contribuição</label>
      <div class="row">
        <input id="sol" type="number" step="0.01" min="0" value="0.10" />
        <button class="btn" id="btnBuy">Comprar no Pump</button>
      </div>

      <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
      <div class="smallnote">Estimativa demo (não é cotação real).</div>
    </div>

    <div id="telemetry" class="glass">
      <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
      <canvas id="wave"></canvas>
      <div id="telemetryHint">Carregando…</div>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const PUMP_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";

const FILES = {
  br: ["BR_IBGE_simplificado.geojson","BR_IBGE.geojson"],
  macro: ["macro_rh.geojson"],
  micro: ["micro_rh.geojson"],
  cnt: ["CNT_FULL_10Y.geojson","dados_cnt.json"],
  basePng: ["mapa_base.png"],
  prodesPng: ["prodes_mosaic.png"]
};

const ECO_SCALE_MULT = 4;     // ECO/100 = cnt_A * 4
const rate = 147449130;       // demo SOL -> CNT

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
const mapMsg = document.getElementById("mapMsg");

function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

async function fetchJSON(path){
  const res = await fetch(path, { cache:"no-store" });
  if(!res.ok) throw new Error(`${path} HTTP ${res.status}`);
  return res.json();
}
async function fetchFirst(paths){
  const errs = [];
  for(const p of paths){
    try { return { data: await fetchJSON(p), path:p }; }
    catch(e){ errs.push(String(e.message||e)); }
  }
  throw new Error(errs.join(" | "));
}
function loadImage(src){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.decoding = "async";
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error("Falha ao carregar: " + src));
    img.src = src + (src.includes("?") ? "" : ("?v=" + Date.now()));
  });
}
async function loadFirstImage(paths){
  let lastErr=null;
  for(const p of paths){
    try { return { img: await loadImage(p), path:p }; }
    catch(e){ lastErr=e; }
  }
  throw lastErr || new Error("Sem imagens");
}

/* GEO helpers */
function isGeomOK(g){ return g && (g.type==="Polygon" || g.type==="MultiPolygon"); }
function extractGeoms(obj){
  const out=[];
  if(!obj) return out;
  if(obj.type==="FeatureCollection" && Array.isArray(obj.features)){
    for(const f of obj.features){
      const g = f?.geometry;
      if(isGeomOK(g)) out.push(g);
      if(g?.type==="GeometryCollection"){
        for(const gg of (g.geometries||[])) if(isGeomOK(gg)) out.push(gg);
      }
    }
  } else if(obj.type==="Feature"){
    const g=obj.geometry;
    if(isGeomOK(g)) out.push(g);
  } else if(isGeomOK(obj)) out.push(obj);
  return out;
}
function mergeToMultiPolygon(geoms){
  const mp={type:"MultiPolygon",coordinates:[]};
  for(const g of geoms){
    if(g.type==="Polygon") mp.coordinates.push(g.coordinates);
    else if(g.type==="MultiPolygon") mp.coordinates.push(...g.coordinates);
  }
  return mp;
}
function bboxFromCoords(coords){
  let minLon=+Infinity, minLat=+Infinity, maxLon=-Infinity, maxLat=-Infinity;
  const walk=(arr)=>{
    for(const v of arr){
      if(Array.isArray(v[0])) walk(v);
      else{
        const lon=v[0], lat=v[1];
        if(lon<minLon) minLon=lon;
        if(lat<minLat) minLat=lat;
        if(lon>maxLon) maxLon=lon;
        if(lat>maxLat) maxLat=lat;
      }
    }
  };
  walk(coords);
  return [minLon,minLat,maxLon,maxLat];
}
function projectFactory(bbox, W, H, pad=0.06){
  const [minLon, minLat, maxLon, maxLat] = bbox;
  const wLon = maxLon - minLon;
  const hLat = maxLat - minLat;
  const padX = W * pad, padY = H * pad;

  const sx = (W - padX*2) / wLon;
  const sy = (H - padY*2) / hLat;
  const s = Math.min(sx, sy);

  const drawW = wLon * s, drawH = hLat * s;
  const ox = (W - drawW)/2;
  const oy = (H - drawH)/2;

  return (lon, lat)=>[ ox + (lon - minLon)*s, oy + (maxLat - lat)*s ];
}

/* =========================
   CANVAS
========================= */
const cnvBase  = document.getElementById("cnvBase");
const cnvHydro = document.getElementById("cnvHydro");
const cnvBorder= document.getElementById("cnvBorder");
const cnvPoints= document.getElementById("cnvPoints");
const ctxBase = cnvBase.getContext("2d");
const ctxH = cnvHydro.getContext("2d");
const ctxB = cnvBorder.getContext("2d");
const ctxP = cnvPoints.getContext("2d");

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const W = Math.max(1, cnv.clientWidth);
  const H = Math.max(1, cnv.clientHeight);
  cnv.width = Math.floor(W * dpr);
  cnv.height = Math.floor(H * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {W,H,dpr};
}
function resizeAll(){
  resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvHydro, ctxH);
  resizeCanvas(cnvBorder, ctxB);
  resizeCanvas(cnvPoints, ctxP);
  resizeWave();
}
window.addEventListener("resize", ()=>{
  resizeAll();
  if(state.bbox){
    state.proj = projectFactory(state.bbox, cnvBase.clientWidth, cnvBase.clientHeight, 0.06);
    redrawStatic();
    rebuildPointField();
  }
});

/* =========================
   STATE
========================= */
const state = {
  brGeom:null,
  bbox:null,
  proj:null,
  cntProps:null,
  series:[],
  imgs:{ base:null, prodes:null },
  pointField:{ points:[], time:0, src:"" },
  hydro:{ macro:null, micro:null }
};

/* =========================
   DRAW STATIC (base + hydro + border)
========================= */
function makePath(ctx){
  if(!state.brGeom) return;
  ctx.beginPath();
  for(const poly of state.brGeom.coordinates){
    const outer = poly[0];
    for(let i=0;i<outer.length;i++){
      const [x,y]=state.proj(outer[i][0], outer[i][1]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
  }
}

function drawRasterBaseUnclipped(){
  const W = cnvBase.clientWidth, H = cnvBase.clientHeight;
  ctxBase.clearRect(0,0,W,H);

  const grd = ctxBase.createRadialGradient(W*0.50,H*0.45, 10, W*0.50,H*0.50, Math.max(W,H)*0.70);
  grd.addColorStop(0, "rgba(90,220,255,0.18)");
  grd.addColorStop(0.6, "rgba(40,120,170,0.10)");
  grd.addColorStop(1, "rgba(0,0,0,0)");
  ctxBase.fillStyle = grd;
  ctxBase.fillRect(0,0,W,H);

  if(state.imgs.base){
    ctxBase.globalAlpha = 0.95;
    ctxBase.drawImage(state.imgs.base, 0, 0, W, H);
    ctxBase.globalAlpha = 1;
  }
  if(state.imgs.prodes){
    ctxBase.globalAlpha = 0.28;
    ctxBase.drawImage(state.imgs.prodes, 0, 0, W, H);
    ctxBase.globalAlpha = 1;
  }
}

function drawRasterBaseClipped(){
  const W = cnvBase.clientWidth, H = cnvBase.clientHeight;
  drawRasterBaseUnclipped();
  if(!state.brGeom) return;

  ctxBase.save();
  makePath(ctxBase);
  ctxBase.clip("evenodd");

  ctxBase.clearRect(0,0,W,H);
  ctxBase.fillStyle = "rgba(0,0,0,0)";
  ctxBase.fillRect(0,0,W,H);

  const grd2 = ctxBase.createRadialGradient(W*0.50,H*0.45, 10, W*0.50,H*0.50, Math.max(W,H)*0.70);
  grd2.addColorStop(0, "rgba(90,220,255,0.10)");
  grd2.addColorStop(0.7, "rgba(0,0,0,0.00)");
  grd2.addColorStop(1, "rgba(0,0,0,0.00)");
  ctxBase.fillStyle = grd2;
  ctxBase.fillRect(0,0,W,H);

  if(state.imgs.base){
    ctxBase.globalAlpha = 0.95;
    ctxBase.drawImage(state.imgs.base, 0, 0, W, H);
    ctxBase.globalAlpha = 1;
  }
  if(state.imgs.prodes){
    ctxBase.globalAlpha = 0.35;
    ctxBase.drawImage(state.imgs.prodes, 0, 0, W, H);
    ctxBase.globalAlpha = 1;
  }

  ctxBase.restore();
}

function drawBorder(){
  const W = cnvBorder.clientWidth, H = cnvBorder.clientHeight;
  ctxB.clearRect(0,0,W,H);
  if(!state.brGeom) return;

  ctxB.save();
  ctxB.lineJoin="round"; ctxB.lineCap="round";

  const strokeOnce = (w, col, blur, shadowCol)=>{
    ctxB.lineWidth = w;
    ctxB.strokeStyle = col;
    ctxB.shadowBlur = blur;
    ctxB.shadowColor = shadowCol;
    makePath(ctxB);
    ctxB.stroke();
  };
  strokeOnce(8, "rgba(120,220,255,0.20)", 18, "rgba(120,220,255,.55)");
  strokeOnce(3, "rgba(120,220,255,0.82)", 10, "rgba(120,220,255,.65)");
  ctxB.restore();
}

function drawHydro(geo, width, col, blur){
  if(!geo) return;
  ctxH.save();
  ctxH.lineJoin="round"; ctxH.lineCap="round";
  ctxH.lineWidth = width;
  ctxH.strokeStyle = col;
  ctxH.shadowBlur = blur;
  ctxH.shadowColor = "rgba(40,170,255,.65)";
  ctxH.beginPath();

  const addLine = (coords)=>{
    for(let i=0;i<coords.length;i++){
      const c=coords[i];
      const [x,y]=state.proj(c[0], c[1]);
      if(i===0) ctxH.moveTo(x,y); else ctxH.lineTo(x,y);
    }
  };

  const feats = geo.features || [];
  for(const f of feats){
    const g=f.geometry;
    if(!g) continue;
    if(g.type==="LineString") addLine(g.coordinates);
    else if(g.type==="MultiLineString"){
      for(const ls of g.coordinates) addLine(ls);
    }
  }
  ctxH.stroke();
  ctxH.restore();
}

function redrawStatic(){
  ctxH.clearRect(0,0,cnvHydro.clientWidth, cnvHydro.clientHeight);
  drawRasterBaseClipped();
  drawHydro(state.hydro.micro, 1.1, "rgba(40,170,255,0.35)", 10);
  drawHydro(state.hydro.macro, 1.8, "rgba(40,200,255,0.55)", 14);
  drawBorder();
}

/* =========================
   POINT FIELD (cores reais do prodes_mosaic.png)
========================= */
function classifyRGB(r,g,b){
  if(b > 120 && b > r+30 && b > g+20) return ["water", 40,170,255];
  if(r > 140 && r > g+35 && r > b+35) return ["defor", 255,80,60];
  if(r > 150 && g > 120 && b < 140) return ["trans", 255,210,70];
  return ["veg", 90,255,180];
}

function rebuildPointField(){
  const W = cnvPoints.clientWidth, H = cnvPoints.clientHeight;
  state.pointField.points = [];
  state.pointField.src = state.imgs.prodes ? "prodes_mosaic.png" : "random";

  const area = W*H;
  const target = Math.max(1800, Math.min(12000, Math.floor(area/65)));

  if(state.imgs.prodes){
    const off = document.createElement("canvas");
    off.width = W; off.height = H;
    const octx = off.getContext("2d", { willReadFrequently:true });
    octx.drawImage(state.imgs.prodes, 0, 0, W, H);
    const img = octx.getImageData(0,0,W,H).data;

    let tries = 0;
    while(state.pointField.points.length < target && tries < target*40){
      tries++;
      const x = (Math.random()*W)|0;
      const y = (Math.random()*H)|0;
      const i = (y*W + x)*4;
      const r=img[i], g=img[i+1], b=img[i+2], a=img[i+3];
      if(a < 40) continue;
      if(r+g+b < 45) continue;

      const [cls, rr, gg, bb] = classifyRGB(r,g,b);
      const size = 0.55 + Math.random()*1.15;
      const speed = 0.8 + Math.random()*1.6;
      const phase = Math.random()*Math.PI*2;
      state.pointField.points.push({x,y, rr,gg,bb, size, speed, phase});
    }
  } else {
    for(let i=0;i<target;
