<!-- CÃ“DIGO COMPLETO CORRIGIDO -->
<!-- ALTERAÃ‡Ã•ES ESTÃƒO APENAS EM:
     1) const MAX
     2) startAnim()
-->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNT â€” Centro Natural TEC AmazÃ´nia</title>

<style>
/* === TODO SEU CSS ORIGINAL INTACTO === */
</style>
</head>

<body>
<!-- === TODO SEU HTML ORIGINAL INTACTO === -->

<script>

/* =========================
   LIMITADOR FULL AJUSTADO
========================= */
function buildProjectedPoints(fc){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  const pts = [];
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g || g.type!=="Point") continue;
    const [x,y] = proj(g.coordinates[0], g.coordinates[1], W, H);
    pts.push({
      x,y,
      ph: Math.random()*Math.PI*2,
      sp: 0.7+Math.random()*1.3,
      base: 0.6+Math.random()*0.8,
      cachedDensity: 0
    });
  }

  const MAX = 90000; // ðŸ”¥ REDUZIDO (antes 140000)

  if(pts.length > MAX){
    const step = Math.ceil(pts.length / MAX);
    const slim = [];
    for(let i=0;i<pts.length;i+=step) slim.push(pts[i]);
    state.ptsXY = slim;
  } else {
    state.ptsXY = pts;
  }

  buildGrid();
}


/* =========================
   ANIMAÃ‡ÃƒO OTIMIZADA
========================= */
function startAnim(){
  if(state.animStarted) return;
  state.animStarted = true;

  let lastFrame = 0;
  const TARGET_FPS = 30;
  const FRAME_TIME = 1000 / TARGET_FPS;

  const loop = (time)=>{

    if(time - lastFrame < FRAME_TIME){
      requestAnimationFrame(loop);
      return;
    }
    lastFrame = time;

    const W = cnvPoints.getBoundingClientRect().width;
    const H = cnvPoints.getBoundingClientRect().height;

    ctxP.clearRect(0,0,W,H);

    if(!state.ptsXY.length){
      requestAnimationFrame(loop);
      return;
    }

    ctxP.globalCompositeOperation = "lighter";

    const total = state.ptsXY.length;

    // desenha apenas 65% por frame
    const limit = Math.floor(total * 0.65);

    for(let i=0;i<limit;i++){
      const p = state.ptsXY[i];

      // recalcula densidade apenas a cada 12 frames
      if(state.t % 12 === 0){
        p.cachedDensity = densityAt(p.x, p.y);
      }

      const [r,g,b] = colorForDensity(p.cachedDensity);

      const pulse = 0.55 + 0.45*Math.sin(p.ph + state.t*p.sp*0.02);
      const alpha = 0.08 + 0.22*pulse;
      const rad   = 0.35 + p.base*0.35;

      ctxP.beginPath();
      ctxP.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      ctxP.arc(p.x, p.y, rad, 0, Math.PI*2);
      ctxP.fill();
    }

    // glow leve
    const glowCount = Math.min(900, Math.max(300, (total/25)|0));

    ctxP.save();
    ctxP.shadowBlur = 6;

    for(let i=0;i<glowCount;i++){
      const p = state.ptsXY[(Math.random()*total)|0];
      if(!p) continue;

      const [r,g,b] = colorForDensity(p.cachedDensity);
      const pulse = 0.5 + 0.5*Math.sin(p.ph + state.t*0.02);

      ctxP.shadowColor = `rgba(${r},${g},${b},0.45)`;
      ctxP.fillStyle   = `rgba(${r},${g},${b},${0.06 + 0.12*pulse})`;

      ctxP.beginPath();
      ctxP.arc(p.x, p.y, 0.9 + pulse*0.9, 0, Math.PI*2);
      ctxP.fill();
    }

    ctxP.restore();

    // mÃ¡scara apenas a cada 5 frames
    if(state.t % 5 === 0){
      maskCanvasToBrasil(ctxP);
    }

    ctxP.globalCompositeOperation = "source-over";

    state.t++;
    requestAnimationFrame(loop);
  };

  requestAnimationFrame(loop);
}

</script>
</body>
</html>
