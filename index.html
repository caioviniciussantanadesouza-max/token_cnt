<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNT — Centro Natural TEC Amazônia</title>

<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
  overflow:hidden;
}
#app{
  position:fixed; inset:0;
  display:grid;
  grid-template-columns: 300px 1fr 360px;
  grid-template-rows: 120px minmax(0,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:14px 16px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:8px;
}
#header h1{
  margin:0;
  font-size:26px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}
.chip.btn{
  cursor:pointer;
  border-color: rgba(110,210,255,.45);
  background: rgba(0,0,0,.28);
  font-weight:900;
}
.chip.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.22); }

/* Left */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:56px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }

.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }

#status{
  margin-top:6px;
  font-size:10px;
  color:rgba(180,245,255,.92);
  opacity:.95;
  line-height:1.35;
  white-space:pre-line;
  user-select:text;
}

/* Center */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
#mapStage{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  perspective: 950px;
}
#map3d{
  position:relative;
  width: min(100%, 980px);
  height: min(100%, 640px);
  aspect-ratio: 980/640;
  transform-style: preserve-3d;
  will-change: transform;
  border-radius: 20px;
  filter: drop-shadow(0 0 18px rgba(110,210,255,.12));
}
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
  border-radius:20px;
}

#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.22;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.22), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.16), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.10), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
  border-radius:24px;
}
@keyframes glowPulse{
  0%{ opacity:.16; transform:scale(1); }
  50%{ opacity:.30; transform:scale(1.02); }
  100%{ opacity:.16; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
  border-radius:20px;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

/* hologram FX overlay */
#holoFX{ position:absolute; inset:0; pointer-events:none; mix-blend-mode: screen; opacity:.75; border-radius:20px; }
#holoGrid{
  position:absolute; inset:0; border-radius:20px;
  background:
    repeating-linear-gradient(0deg, rgba(110,210,255,.08) 0px, rgba(110,210,255,.08) 1px, transparent 4px, transparent 8px),
    repeating-linear-gradient(90deg, rgba(110,210,255,.05) 0px, rgba(110,210,255,.05) 1px, transparent 10px, transparent 18px);
  opacity:.22;
  animation: holoMove 6.5s linear infinite;
}
@keyframes holoMove{ 0%{ transform: translate3d(-10px,-10px,0);} 100%{ transform: translate3d(10px,10px,0);} }
#holoSheen{
  position:absolute; inset:-30%;
  border-radius:50%;
  background: radial-gradient(circle at 30% 35%, rgba(110,210,255,.20), rgba(0,0,0,0) 55%);
  filter: blur(10px);
  opacity:.35;
  animation: sheen 4.5s ease-in-out infinite;
}
@keyframes sheen{
  0%{ transform: translate3d(-6%, -4%, 0) scale(1); opacity:.26; }
  50%{ transform: translate3d(10%, 6%, 0) scale(1.05); opacity:.42; }
  100%{ transform: translate3d(-6%, -4%, 0) scale(1); opacity:.26; }
}
#holoVignette{
  position:absolute; inset:0; border-radius:20px;
  background: radial-gradient(70% 60% at 50% 45%, rgba(0,0,0,0), rgba(0,0,0,.60) 85%);
  opacity:.9;
}

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }

.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }

#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
}

@media (max-width: 1100px){
  body{ overflow:auto; }
  #app{ position:relative; grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; }
  #center{ height:48vh; }
}
</style>
</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — Centro Natural TEC Amazônia</h1>
    <p class="sub">Mapa base + holografia 3D • Brasil inteiro • pontos contínuos • alertas reais</p>
    <div id="chips">
      <div class="chip" id="chipAOI">AOI: Brasil</div>
      <div class="chip" id="chipDados">dados_cnt: …</div>
      <div class="chip" id="chipPNG">PNG: …</div>
      <div class="chip" id="chipAlerts">alerts_2024: …</div>
      <div class="chip btn" id="btnFull">Carregar FULL (manual)</div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

    <div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
    <div class="small">RAW auditável: <b id="raw">--</b></div>

    <div class="hr"></div>

    <div class="abclist">
      <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
      <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
      <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
      <div class="abcline"><b>Grau</b><span id="R">--</span></div>
    </div>

    <div class="hr"></div>

    <div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
    <div class="grid2">
      <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
      <div class="kv"><b>IAB</b><span id="iab">--</span></div>
      <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
      <div class="kv"><b>HID</b><span id="hid">--</span></div>
      <div class="kv"><b>ENT</b><span id="ent">--</span></div>
      <div class="kv"><b>PAN</b><span id="pan">--</span></div>
    </div>

    <div id="status">Status: iniciando…</div>
  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <div id="mapStage">
        <div id="map3d">
          <!-- ordem: base -> holo -> linhas -> pontos -> alertas -->
          <canvas id="cnvBase" class="layer"></canvas>
          <canvas id="cnvHolo" class="layer"></canvas>
          <canvas id="cnvLines" class="layer"></canvas>
          <canvas id="cnvPoints" class="layer"></canvas>
          <canvas id="cnvAlerts" class="layer"></canvas>

          <div id="mapGlow"></div>
          <div id="scanlines"></div>

          <div id="holoFX">
            <div id="holoGrid"></div>
            <div id="holoSheen"></div>
            <div id="holoVignette"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>
      <p class="mut">Abre o token no Pump.fun.</p>

      <label for="sol">Contribuição</label>
      <div class="row">
        <input id="sol" type="number" step="0.01" min="0" value="0.10" />
        <button class="btn" id="btnBuy">Comprar no Pump</button>
      </div>

      <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
      <div class="smallnote">Estimativa demo (não é cotação real).</div>
    </div>

    <div id="telemetry" class="glass">
      <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
      <canvas id="wave"></canvas>
      <div id="telemetryHint">Carregando…</div>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG (ajuste só aqui)
========================= */
const PUMP_FALLBACK = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";
const RATE_DEMO = 147449130;

// arquivos (não inventa pasta — mantém compatível com teu repo)
const CAND = {
  // Brasil (mask)
  brasil: [
    "./BR_IBGE_simplificado.geojson",
    "./BR_IBGE.geojson",
    "./dados/BR_IBGE_simplificado.geojson",
    "./dados/BR_IBGE.geojson",
  ],
  // linhas
  uf:    ["./uf.geojson","./dados/uf.geojson"],
  macro: ["./macro_rh.geojson","./dados/macro_rh.geojson"],
  micro: ["./micro_rh.geojson","./dados/micro_rh.geojson"],

  // base/holo PNG
  basePNG: ["./mapa_base.png","./mapa_base.PNG","./assets/mapa_base.png","./img/mapa_base.png"],
  holoPNG: ["./mapa_holo.png","./mapa_holo.PNG","./assets/mapa_holo.png","./img/mapa_holo.png"],

  // pontos
  pts_sample: ["./vege_pts_sample.geojson","./dados/vege_pts_sample.geojson"],
  pts_full:   ["./vege_pts.geojson","./dados/vege_pts.geojson"],

  // índices e alertas
  dados_cnt: ["./dados_cnt.json","./dados/dados_cnt.json"],
  alerts:    ["./dados/alerts_2024.geojson","./alerts_2024.geojson"]
};

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
const diag = { ok:[], fail:[] };

function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

async function tryFetchJSON(url){
  const res = await fetch(url + "?v=" + Date.now(), { cache:"no-store" });
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.json();
}
async function fetchFirstJSON(list, label){
  let last=null;
  for(const url of list){
    try{
      const data = await tryFetchJSON(url);
      diag.ok.push(`${label}: OK  ← ${url}`);
      return {url, data};
    }catch(e){
      last=e;
      diag.fail.push(`${label}: FAIL (${e.message}) ← ${url}`);
    }
  }
  throw last || new Error(`${label} não encontrado`);
}
function loadImage(url){
  return new Promise((resolve)=>{
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=> resolve({url, img});
    img.onerror = ()=> resolve({url, img:null});
    img.src = url + "?v=" + Date.now();
  });
}
async function loadFirstImage(list, label){
  for(const url of list){
    const r = await loadImage(url);
    if(r.img){
      diag.ok.push(`${label}: OK  ← ${url}`);
      return r;
    }
    diag.fail.push(`${label}: FAIL ← ${url}`);
  }
  return {url:list[0], img:null};
}
function printDiag(){
  statusEl.textContent =
    "DIAG (o que carregou / o que falhou)\n\n" +
    "OK:\n- " + (diag.ok.length ? diag.ok.join("\n- ") : "(nada)") + "\n\n" +
    "FAIL:\n- " + (diag.fail.length ? diag.fail.join("\n- ") : "(nada)") + "\n";
}

function walkCoords(arr, cb){
  if(!arr) return;
  if(typeof arr[0] === "number") cb(arr);
  else for(const a of arr) walkCoords(a, cb);
}
function calcBBox(fc){
  let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    walkCoords(g.coordinates, (c)=>{
      const x=c[0], y=c[1];
      if(x<minx)minx=x; if(y<miny)miny=y;
      if(x>maxx)maxx=x; if(y>maxy)maxy=y;
    });
  }
  return [minx, miny, maxx, maxy];
}

let bbox=null, maskFC=null;
function proj(lon,lat,w,h){
  const [minx,miny,maxx,maxy] = bbox;
  return [
    (lon-minx)/(maxx-minx)*w,
    (maxy-lat)/(maxy-miny)*h
  ];
}

/* =========================
   CANVAS
========================= */
const cnvBase   = document.getElementById("cnvBase");
const cnvHolo   = document.getElementById("cnvHolo");
const cnvLines  = document.getElementById("cnvLines");
const cnvPoints = document.getElementById("cnvPoints");
const cnvAlerts = document.getElementById("cnvAlerts");

const ctxBase = cnvBase.getContext("2d");
const ctxH    = cnvHolo.getContext("2d");
const ctxL    = cnvLines.getContext("2d");
const ctxP    = cnvPoints.getContext("2d");
const ctxA    = cnvAlerts.getContext("2d");

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const r = cnv.getBoundingClientRect();
  cnv.width  = Math.max(2, Math.floor(r.width  * dpr));
  cnv.height = Math.max(2, Math.floor(r.height * dpr));
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function resizeAll(){
  resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvHolo, ctxH);
  resizeCanvas(cnvLines, ctxL);
  resizeCanvas(cnvPoints, ctxP);
  resizeCanvas(cnvAlerts, ctxA);
  resizeWave();
  if(state.ready) {
    redrawStatic();
    if(state.ptsXY.length) buildHeatGrid();
  }
}
window.addEventListener("resize", resizeAll);

function clear(ctx){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctx.clearRect(0,0,W,H);
}

/* recorte Brasil */
function clipToMask(ctx){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  ctx.save();
  ctx.globalCompositeOperation = "destination-in";
  ctx.fillStyle = "#fff";
  ctx.beginPath();

  for(const f of (maskFC.features||[])){
    const g = f.geometry;
    if(!g) continue;
    const polys = (g.type==="Polygon") ? [g.coordinates] : (g.type==="MultiPolygon" ? g.coordinates : []);
    for(const poly of polys){
      const outer = poly[0];
      if(!outer || outer.length<3) continue;
      for(let i=0;i<outer.length;i++){
        const [x,y] = proj(outer[i][0], outer[i][1], W, H);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }
  }

  ctx.fill();
  ctx.restore();
  ctx.globalCompositeOperation = "source-over";
}

function drawCover(ctx, img){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  const iw = img.naturalWidth || 980;
  const ih = img.naturalHeight || 640;

  const s = Math.max(W/iw, H/ih);
  const dw = iw*s, dh = ih*s;
  const dx = (W - dw)/2;
  const dy = (H - dh)/2;

  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(img, dx, dy, dw, dh);
  ctx.restore();
}

/* linhas geojson */
function strokeLines(ctx, fc, strokeStyle, width, alpha){
  if(!fc) return;
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = width;
  ctx.lineJoin="round";
  ctx.lineCap="round";

  const drawLine = (line)=>{
    if(!line || line.length<2) return;
    ctx.beginPath();
    for(let i=0;i<line.length;i++){
      const [x,y]=proj(line[i][0], line[i][1], W, H);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  };

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    if(g.type==="LineString") drawLine(g.coordinates);
    else if(g.type==="MultiLineString") for(const ln of g.coordinates) drawLine(ln);
    else if(g.type==="Polygon") drawLine(g.coordinates[0]);
    else if(g.type==="MultiPolygon") for(const poly of g.coordinates) drawLine(poly[0]);
  }

  ctx.restore();
}

/* =========================
   STATE
========================= */
const state = {
  ready:false,
  uf:null, macro:null, micro:null,
  baseImg:null, holoImg:null,
  ptsXY:[],
  heat:null,
  alerts:[],
  t:0,
  animStarted:false,
  alertsStarted:false,
  fullLoaded:false,
  pumpUrl:PUMP_FALLBACK
};

/* =========================
   MAPA: static layers
========================= */
function drawProceduralHolo(ctx){
  // fallback se mapa_holo.png não existir: holograma procedural
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  const g1 = ctx.createRadialGradient(W*0.35,H*0.35,10, W*0.45,H*0.45, Math.max(W,H)*0.8);
  g1.addColorStop(0, "rgba(0,255,220,0.18)");
  g1.addColorStop(0.35, "rgba(0,140,255,0.12)");
  g1.addColorStop(1, "rgba(0,0,0,0)");
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  ctx.fillStyle = g1;
  ctx.fillRect(0,0,W,H);

  // scan bands
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "rgba(0,255,220,0.10)";
  for(let y=0; y<H; y+=18){
    ctx.fillRect(0,y, W, 1);
  }
  ctx.restore();
}

function redrawStatic(){
  if(!bbox || !maskFC) return;

  clear(ctxBase); clear(ctxH); clear(ctxL);

  // base
  if(state.baseImg){
    drawCover(ctxBase, state.baseImg);
  } else {
    const W = cnvBase.getBoundingClientRect().width;
    const H = cnvBase.getBoundingClientRect().height;
    ctxBase.fillStyle = "#000";
    ctxBase.fillRect(0,0,W,H);
  }
  clipToMask(ctxBase);

  // holo overlay (png ou procedural)
  if(state.holoImg){
    ctxH.save();
    ctxH.globalCompositeOperation = "screen";
    ctxH.globalAlpha = 0.95;
    drawCover(ctxH, state.holoImg);
    ctxH.restore();
  } else {
    drawProceduralHolo(ctxH);
  }
  clipToMask(ctxH);

  // linhas
  strokeLines(ctxL, state.macro, "rgba(0,234,255,0.85)", 1.15, 1);
  strokeLines(ctxL, state.micro, "rgba(0,120,255,0.55)", 0.55, 1);
  strokeLines(ctxL, state.uf,    "rgba(160,245,255,0.45)", 0.85, 1);
  clipToMask(ctxL);
}

/* =========================
   PONTOS: leve, contínuo, não trava
========================= */
function buildProjectedPoints(fc){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  const pts = [];
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g || g.type!=="Point") continue;
    const [x,y] = proj(g.coordinates[0], g.coordinates[1], W, H);
    pts.push({ x,y, ph: Math.random()*Math.PI*2, sp: 0.7+Math.random()*1.3, base: 0.6+Math.random()*0.8 });
  }

  // cap pra não explodir
  const MAX = 170000;
  if(pts.length > MAX){
    const step = Math.ceil(pts.length / MAX);
    const slim = [];
    for(let i=0;i<pts.length;i+=step) slim.push(pts[i]);
    state.ptsXY = slim;
  } else state.ptsXY = pts;

  buildHeatGrid();
}

// heat-grid: cor por densidade local sem custo alto
function buildHeatGrid(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  const cell = 6; // fino o bastante e leve
  const cols = Math.ceil(W / cell);
  const rows = Math.ceil(H / cell);
  const g = new Uint16Array(cols * rows);

  for(const p of state.ptsXY){
    const cx = Math.max(0, Math.min(cols - 1, (p.x / cell) | 0));
    const cy = Math.max(0, Math.min(rows - 1, (p.y / cell) | 0));
    g[cy * cols + cx]++;
  }

  // blur 3x3 simples
  const out = new Uint16Array(cols * rows);
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      let sum=0, n=0;
      for(let oy=-1; oy<=1; oy++){
        const yy=y+oy; if(yy<0||yy>=rows) continue;
        for(let ox=-1; ox<=1; ox++){
          const xx=x+ox; if(xx<0||xx>=cols) continue;
          sum += g[yy*cols + xx];
          n++;
        }
      }
      out[y*cols + x] = (sum / Math.max(1,n)) | 0;
    }
  }

  let max=1;
  for(let i=0;i<out.length;i++) if(out[i] > max) max = out[i];
  state.heat = { cell, cols, rows, data: out, max };
}

function heatAt(x,y){
  const h = state.heat;
  if(!h) return 0;
  const cx = Math.max(0, Math.min(h.cols - 1, (x / h.cell) | 0));
  const cy = Math.max(0, Math.min(h.rows - 1, (y / h.cell) | 0));
  const v = h.data[cy * h.cols + cx];
  return Math.min(1, v / Math.max(1, h.max));
}

function rgbForNorm(norm){
  if(norm >= 0.70) return [60, 255, 180];  // verde
  if(norm >= 0.40) return [255, 235, 90];  // amarelo
  return [255, 80, 60];                    // vermelho
}

function startPointsAnim(){
  if(state.animStarted) return;
  state.animStarted = true;

  let cursor = 0;

  const loop = ()=>{
    const W = cnvPoints.getBoundingClientRect().width;
    const H = cnvPoints.getBoundingClientRect().height;
    ctxP.clearRect(0,0,W,H);

    if(state.ptsXY.length && state.heat){
      ctxP.globalCompositeOperation = "lighter";

      // budget de tempo por frame (evita travar em PC fraco)
      const start = performance.now();
      const budgetMs = 7.5;

      // stride dinâmico (se tiver MUITO ponto, ele pula mais)
      const N = state.ptsXY.length;
      let stride = 1;
      if(N > 120000) stride = 2;
      if(N > 160000) stride = 3;

      // desenha em “anéis” usando cursor (não tenta desenhar tudo todo frame)
      while(performance.now() - start < budgetMs){
        const p = state.ptsXY[cursor];
        const norm = heatAt(p.x, p.y);
        const [r,g,b] = rgbForNorm(norm);

        const pulse = 0.55 + 0.45*Math.sin(p.ph + state.t*p.sp*0.022);
        const alpha = 0.06 + 0.22*pulse;
        const rad   = 0.30 + p.base*0.35;

        ctxP.beginPath();
        ctxP.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctxP.arc(p.x, p.y, rad, 0, Math.PI*2);
        ctxP.fill();

        cursor = (cursor + stride) % N;
      }

      // sparkles (fixo e leve)
      const glowCount = 520;
      ctxP.save();
      ctxP.shadowBlur = 10;
      for(let i=0;i<glowCount;i++){
        const p = state.ptsXY[(Math.random()*state.ptsXY.length)|0];
        const norm = heatAt(p.x, p.y);
        const [r,g,b] = rgbForNorm(norm);
        const pulse = 0.55 + 0.45*Math.sin(p.ph + state.t*0.03);
        const alpha = 0.05 + 0.14*pulse;
        ctxP.shadowColor = `rgba(${r},${g},${b},${0.55})`;
        ctxP.fillStyle   = `rgba(${r},${g},${b},${alpha})`;
        ctxP.beginPath();
        ctxP.arc(p.x, p.y, 1.0 + pulse*1.3, 0, Math.PI*2);
        ctxP.fill();
      }
      ctxP.restore();

      clipToMask(ctxP);
      ctxP.globalCompositeOperation = "source-over";
    }

    state.t += 1;
    requestAnimationFrame(loop);
  };

  requestAnimationFrame(loop);
}

/* =========================
   ALERTAS reais (alerts_2024.geojson)
========================= */
function parseAlerts(fc){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  const out = [];

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;

    // suportar Point e Polygon (usa centroid aproximado)
    let lonlat = null;

    if(g.type === "Point"){
      lonlat = g.coordinates;
    } else {
      // centroid simples (média) para Polygon/MultiPolygon
      let sx=0, sy=0, n=0;
      walkCoords(g.coordinates, (c)=>{
        sx += c[0]; sy += c[1]; n++;
      });
      if(n>0) lonlat = [sx/n, sy/n];
    }

    if(!lonlat) continue;
    const [x,y] = proj(lonlat[0], lonlat[1], W, H);

    const p = f.properties || {};
    const sev = String(p.severity || p.nivel || p.level || "medium").toLowerCase();
    const kind = String(p.type || p.tipo || "alert").toLowerCase();

    out.push({
      x,y,
      sev,
      kind,
      ph: Math.random()*Math.PI*2
    });
  }
  return out;
}

function colorForAlert(sev){
  if(sev.includes("high") || sev.includes("alto") || sev.includes("crit")) return [255,70,55];
  if(sev.includes("med")  || sev.includes("moder")) return [255,185,70];
  return [110,210,255];
}

function startAlertsAnim(){
  if(state.alertsStarted) return;
  state.alertsStarted = true;

  const loop = ()=>{
    const W = cnvAlerts.getBoundingClientRect().width;
    const H = cnvAlerts.getBoundingClientRect().height;
    ctxA.clearRect(0,0,W,H);

    if(state.alerts.length){
      ctxA.globalCompositeOperation = "lighter";

      const t = state.t * 0.06;
      for(const a of state.alerts){
        const [r,g,b] = colorForAlert(a.sev);
        const pulse = 0.5 + 0.5*Math.sin(a.ph + t);

        // ponto central
        ctxA.beginPath();
        ctxA.fillStyle = `rgba(${r},${g},${b},${0.45 + 0.35*pulse})`;
        ctxA.arc(a.x, a.y, 1.8 + 0.8*pulse, 0, Math.PI*2);
        ctxA.fill();

        // anel pulsante
        const rad = 10 + 22*pulse;
        ctxA.lineWidth = 1.4;
        ctxA.strokeStyle = `rgba(${r},${g},${b},${0.18 + 0.18*pulse})`;
        ctxA.beginPath();
        ctxA.arc(a.x, a.y, rad, 0, Math.PI*2);
        ctxA.stroke();

        // glow
        ctxA.save();
        ctxA.shadowBlur = 18;
        ctxA.shadowColor = `rgba(${r},${g},${b},${0.55})`;
        ctxA.strokeStyle = `rgba(${r},${g},${b},${0.10 + 0.16*pulse})`;
        ctxA.lineWidth = 2.0;
        ctxA.beginPath();
        ctxA.arc(a.x, a.y, rad*1.15, 0, Math.PI*2);
        ctxA.stroke();
        ctxA.restore();
      }

      clipToMask(ctxA);
      ctxA.globalCompositeOperation = "source-over";
    }

    requestAnimationFrame(loop);
  };

  requestAnimationFrame(loop);
}

/* =========================
   TELEMETRIA (wave)
========================= */
const wave = document.getElementById("wave");
const wctx = wave.getContext("2d");
let tWave=0;

function resizeWave(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  wave.width  = Math.max(2, Math.floor(wave.clientWidth  * dpr));
  wave.height = Math.max(2, Math.floor(wave.clientHeight * dpr));
  wctx.setTransform(dpr,0,0,dpr,0,0);
}

function startWave(series){
  const s = Array.isArray(series) ? series : [];

  const draw = ()=>{
    const W = wave.clientWidth, H = wave.clientHeight;
    wctx.clearRect(0,0,W,H);
    wctx.fillStyle = "rgba(0,0,0,.25)";
    wctx.fillRect(0,0,W,H);

    wctx.strokeStyle = "rgba(110,210,255,.10)";
    wctx.lineWidth = 1;
    for(let y=12; y<H; y+=18){
      wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
    }

    const min = s.length? Math.min(...s) : 0;
    const max = s.length? Math.max(...s) : 1;

    function yAt(i){
      if(s.length>=2){
        const idx = (i / Math.max(1,(W-1))) * (s.length-1);
        const a = Math.floor(idx);
        const b = Math.min(s.length-1, a+1);
        const f = idx - a;
        const v = s[a]*(1-f) + s[b]*f;
        const norm = (max-min) < 1e-9 ? 0.5 : (v - min) / (max - min);
        let y = (H*0.18) + (1-norm) * (H*0.68);
        y += Math.sin((i + tWave)/28) * (H*0.02);
        return y;
      }
      return (H*0.52)
        + Math.sin((i+tWave)/38)*(H*0.20)
        + Math.sin((i+tWave)/13)*(H*0.07);
    }

    wctx.lineWidth = 2;
    wctx.strokeStyle = "rgba(110,210,255,.35)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    wctx.strokeStyle = "rgba(110,210,255,.90)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    tWave += 2;
    requestAnimationFrame(draw);
  };
  draw();
}

/* =========================
   BUY
========================= */
const solInput = document.getElementById("sol");
const out = document.getElementById("out");
function updateOut(){
  const sol = parseFloat(solInput.value) || 0;
  out.textContent = (sol * RATE_DEMO).toLocaleString("pt-BR") + " CNT";
}
solInput.addEventListener("input", updateOut);
updateOut();
document.getElementById("btnBuy").addEventListener("click", ()=>{
  window.open(state.pumpUrl || PUMP_FALLBACK, "_blank", "noopener,noreferrer");
});

/* =========================
   3D tilt
========================= */
(function holoTilt(){
  const box = document.getElementById("map3d");
  const wrap = document.getElementById("mapWrap");
  let mx=0, my=0, rx=0, ry=0;

  window.addEventListener("mousemove", (ev)=>{
    const r = wrap.getBoundingClientRect();
    const x = (ev.clientX - r.left) / r.width;
    const y = (ev.clientY - r.top) / r.height;
    mx = (x - 0.5) * 2;
    my = (y - 0.5) * 2;
  }, {passive:true});

  function tick(){
    ry += ((mx*8) - ry) * 0.08;
    rx += ((-my*6) - rx) * 0.08;
    box.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) translateZ(22px)`;
    requestAnimationFrame(tick);
  }
  tick();
})();

/* =========================
   BOOT (Brasil inteiro)
========================= */
function setChip(id, text){ document.getElementById(id).textContent = text; }

function setText(id, v){ const el = document.getElementById(id); if(el) el.textContent = v; }
function setNumber(id, n, dec=1){ setText(id, Number.isFinite(Number(n)) ? fmt(n,dec) : "--"); }

async function boot(){
  try{
    resizeAll();
    setChip("chipAOI", "AOI: Brasil");
    setChip("chipDados", "dados_cnt: …");
    setChip("chipPNG", "PNG: …");
    setChip("chipAlerts", "alerts_2024: …");

    // 1) Brasil mask (sempre)
    const br = (await fetchFirstJSON(CAND.brasil, "brasil")).data;
    maskFC = br;
    bbox = calcBBox(maskFC);

    // 2) linhas (opcional)
    try{ state.uf    = (await fetchFirstJSON(CAND.uf, "uf")).data; } catch(e){}
    try{ state.macro = (await fetchFirstJSON(CAND.macro, "macro")).data; } catch(e){}
    try{ state.micro = (await fetchFirstJSON(CAND.micro, "micro")).data; } catch(e){}

    // 3) dados_cnt.json (painel)
    let series = [];
    try{
      const {data:dados} = await fetchFirstJSON(CAND.dados_cnt, "dados_cnt");
      setChip("chipDados", "dados_cnt: OK");

      const idx = dados?.indices || dados || {};
      // compatível com formatos diferentes
      const raw = Number(idx.cnt_A_raw ?? idx.RAW ?? idx.raw ?? idx.cnt_A ?? NaN);
      const A100 = Number.isFinite(Number(idx.cnt_A_0_100))
        ? Number(idx.cnt_A_0_100)
        : (Number.isFinite(raw) ? clamp(raw * 4, 0, 100) : NaN);

      setText("raw", fmt(raw,2));
      setText("eco", fmt1(A100));
      setText("A", fmt(A100,2));

      const b = Number(idx.cnt_B ?? idx.B ?? 0);
      setText("B", Number.isFinite(b) ? ((b>=0?"+":"") + fmt(b,2)) : "--");
      setText("C", fmt(idx.cnt_C ?? idx.C, 2));
      setText("R", idx.grade ?? idx.GRAU ?? idx.grau ?? "--");

      // sub-índices: aceita diferentes nomes
      const sub = idx.sub || idx.subindices || idx.sub_indices || {};
      setNumber("ibe", sub.IBE ?? idx.IBE ?? idx.FUNC, 1);
      setNumber("iab", sub.IAB ?? idx.IAB, 1);
      setNumber("ibi", sub.IBI ?? idx.IBI, 1);
      setNumber("hid", sub.HID ?? idx.HID, 1);
      setNumber("ent", sub.ENT ?? idx.ENT, 1);
      setNumber("pan", sub.PAN ?? idx.PAN, 1);

      series = Array.isArray(idx.series_10y) ? idx.series_10y.map(Number).filter(Number.isFinite) : [];
      document.getElementById("telemetryHint").textContent = series.length ? ("Histórico: " + series.length) : "Sem série 10y no JSON.";

      // pump url
      state.pumpUrl = dados?.token?.pump_url || dados?.pump_url || PUMP_FALLBACK;
    }catch(e){
      setChip("chipDados", "dados_cnt: OFF");
      document.getElementById("telemetryHint").textContent = "dados_cnt.json não carregou (veja DIAG).";
    }

    // 4) PNG base + holo
    const baseR = await loadFirstImage(CAND.basePNG, "mapa_base.png");
    const holoR = await loadFirstImage(CAND.holoPNG, "mapa_holo.png");
    state.baseImg = baseR.img;
    state.holoImg = holoR.img;

    // PNG status: base obrigatório pra ficar “perfeito”, mas se faltar ainda roda
    if(state.baseImg) setChip("chipPNG", state.holoImg ? "PNG: OK" : "PNG: base OK / holo OFF");
    else setChip("chipPNG", "PNG: OFF (sem base)");

    // 5) desenha mapa
    state.ready = true;
    redrawStatic();
    startWave(series);

    // 6) pontos sample primeiro
    const ptsSample = (await fetchFirstJSON(CAND.pts_sample, "pts_sample")).data;
    buildProjectedPoints(ptsSample);
    startPointsAnim();

    // 7) alertas
    try{
      const alertsFC = (await fetchFirstJSON(CAND.alerts, "alerts_2024")).data;
      state.alerts = parseAlerts(alertsFC);
      setChip("chipAlerts", state.alerts.length ? `alerts_2024: OK (${state.alerts.length})` : "alerts_2024: OK (0)");
      startAlertsAnim();
    }catch(e){
      setChip("chipAlerts", "alerts_2024: OFF");
    }

    // FULL manual (não trava automático)
    document.getElementById("btnFull").addEventListener("click", async ()=>{
      if(state.fullLoaded) return;
      try{
        const ptsFull = (await fetchFirstJSON(CAND.pts_full, "pts_full")).data;
        buildProjectedPoints(ptsFull);
        state.fullLoaded = true;
        diag.ok.push("FULL: OK (manual)");
        printDiag();
      }catch(e){
        diag.fail.push("FULL: FAIL (não encontrado/erro)");
        printDiag();
      }
    });

    // final: diag
    printDiag();

  }catch(err){
    console.error(err);
    statusEl.textContent = "ERRO GERAL: " + (err?.message || err);
    printDiag();
  }
}
boot();
</script>
</body>
</html>
