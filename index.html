<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNT — Brasil (Todos os Biomas)</title>

<style>
:root{
  --bg0:#000;
  --bg1:#050b10;
  --stroke: rgba(110,210,255,.18);
  --glass: rgba(2,12,24,.46);
  --text: #c8f3ff;
  --muted:#86dcff;
  --shadow: 0 0 22px rgba(110,210,255,.14), 0 0 70px rgba(0,200,255,.08);
}
*{ box-sizing:border-box; }
html,body{
  margin:0;height:100%;
  background: radial-gradient(1200px 700px at 50% 35%, var(--bg1), var(--bg0) 70%);
  color:var(--text);
  font-family:"Segoe UI", Arial, sans-serif;
  overflow:hidden;
}
#app{
  position:fixed; inset:0;
  display:grid;
  grid-template-columns: 300px 1fr 360px;
  grid-template-rows: 120px minmax(0,1fr);
  gap:14px;
  padding:14px;
  align-items:stretch;
}
.glass{
  background: var(--glass);
  backdrop-filter: blur(14px);
  border:1px solid var(--stroke);
  border-radius:22px;
  box-shadow: var(--shadow);
}

/* Header */
#header{
  grid-column:1 / 4;
  padding:14px 16px;
  border-radius:24px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:8px;
}
#header h1{
  margin:0;
  font-size:26px;
  letter-spacing:.6px;
  font-weight:900;
  color:#e9fdff;
  text-align:center;
}
#header .sub{
  margin:0;
  text-align:center;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
#chips{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.chip{
  font-size:11px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(110,210,255,.22);
  background: rgba(0,0,0,.20);
  color:#cfefff;
  opacity:.95;
}
.chip.btn{
  cursor:pointer;
  user-select:none;
  border-color: rgba(110,210,255,.45);
  background: rgba(0,0,0,.28);
  font-weight:900;
}
.chip.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }

/* Left */
#left{
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  overflow:hidden;
}
.big{
  font-size:56px;
  line-height:1;
  font-weight:260;
  color:#e9fdff;
  margin:0;
}
.small{
  font-size:12px;
  color:var(--muted);
  opacity:.95;
}
.hr{
  height:1px;
  background:linear-gradient(90deg,transparent,rgba(110,210,255,.30),transparent);
  margin:6px 0;
}
.abclist{ display:grid; gap:8px; }
.abcline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.14);
  background:rgba(0,0,0,.18);
  border-radius:14px;
  font-size:12px;
}
.abcline b{ color:#e9fdff; font-weight:900; }
.abcline span{ color:#d5fbff; font-weight:900; }
.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px 10px;
}
.kv{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:12px;
  padding:7px 10px;
  border:1px solid rgba(110,210,255,.16);
  border-radius:14px;
  background:rgba(0,0,0,.18);
}
.kv b{ font-weight:900; color:#e9fdff; }
.kv span{ color:#d0fbff; font-weight:900; }
#status{
  margin-top:4px;
  font-size:10px;
  color:rgba(180,245,255,.9);
  opacity:.88;
  line-height:1.25;
  white-space:pre-line;
}

/* Center */
#center{
  position:relative;
  overflow:hidden;
  border-radius:26px;
  min-height:0;
}
#mapWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: radial-gradient(900px 600px at 50% 40%, rgba(20,60,80,.35), rgba(0,0,0,1) 70%);
}
.layer{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#mapGlow{
  position:absolute; inset:-10%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.22;
  filter: blur(12px);
  background:
    radial-gradient(circle at 42% 55%, rgba(120,220,255,.22), transparent 52%),
    radial-gradient(circle at 70% 45%, rgba(120,220,255,.16), transparent 60%),
    radial-gradient(circle at 35% 70%, rgba(120,220,255,.10), transparent 60%);
  animation: glowPulse 6s ease-in-out infinite;
}
@keyframes glowPulse{
  0%{ opacity:.16; transform:scale(1); }
  50%{ opacity:.30; transform:scale(1.02); }
  100%{ opacity:.16; transform:scale(1); }
}
#scanlines{
  position:absolute; inset:0;
  pointer-events:none;
  opacity:.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(120,220,255,.06) 0px,
      rgba(120,220,255,.06) 1px,
      transparent 2px,
      transparent 7px
    );
  mix-blend-mode: overlay;
  animation: scan 3.2s linear infinite;
}
@keyframes scan{ 0%{ transform:translateY(-22px);} 100%{ transform:translateY(22px);} }

/* Right */
#right{
  display:flex;
  flex-direction:column;
  gap:14px;
  min-height:0;
}
#buy, #telemetry{ padding:14px; }
#buy h2{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:.4px;
  color:#e9fdff;
}
#buy .mut{
  margin:8px 0 10px;
  font-size:12px;
  color:var(--muted);
  opacity:.95;
  line-height:1.35;
}
label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
input{
  width:170px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(110,210,255,.35);
  background:rgba(0,0,0,.18);
  color:#e9fbff;
  outline:none;
}
input:focus{
  border-color: rgba(110,210,255,.70);
  box-shadow: 0 0 16px rgba(110,210,255,.18);
}
.btn{
  background:linear-gradient(180deg,rgba(110,210,255,.20),rgba(0,0,0,.16));
  border:1px solid rgba(110,210,255,.45);
  color:#eafcff;
  border-radius:14px;
  padding:10px 13px;
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  min-width:160px;
}
.btn:hover{ box-shadow:0 0 18px rgba(110,210,255,.30); }
.valueLine{ margin-top:10px; font-size:12px; color:#bdf4ff; }
.valueLine b{ font-size:19px; color:#e9fdff; }
.smallnote{ margin-top:6px; font-size:11px; color:var(--muted); opacity:.95; }
#telemetryTitle{
  font-size:12px;
  letter-spacing:.8px;
  color:#d4fbff;
  opacity:.95;
  margin-bottom:8px;
  font-weight:900;
}
#wave{
  width:100%;
  height:74px;
  display:block;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(110,210,255,.14);
  border-radius:14px;
}
#telemetryHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
  opacity:.92;
  white-space:pre-line;
}

@media (max-width: 1100px){
  body{ overflow:auto; }
  #app{ position:relative; grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; }
  #center{ height:48vh; }
}
</style>
</head>

<body>
<div id="app">
  <div id="header" class="glass">
    <h1>CNT — Centro Natural TEC Amazônia</h1>
    <p class="sub">Brasil (todos os biomas) • Água (azul) • Vegetação (verde) • Transição (amarelo) • Desmatamento (vermelho)</p>
    <div id="chips">
      <div class="chip" id="chipSource">Fonte: dados públicos governamentais + MapBiomas</div>
      <div class="chip" id="chipYear">Ano base: 2025</div>
      <div class="chip" id="chipPts">Pontos: --</div>
      <div class="chip" id="chipAlerts">Alertas: --</div>
      <div class="chip btn" id="btnFull">Carregar FULL (vegetação)</div>
    </div>
  </div>

  <div id="left" class="glass">
    <div class="small"><b>CNT</b> (índice único Brasil)</div>

    <div class="big"><span id="eco">--</span><span style="font-size:16px; opacity:.9;">/100</span></div>
    <div class="small">RAW auditável: <b id="raw">--</b></div>

    <div class="hr"></div>

    <div class="abclist">
      <div class="abcline"><b>A — Estado</b><span id="A">--</span></div>
      <div class="abcline"><b>B — Tendência</b><span id="B">--</span></div>
      <div class="abcline"><b>C — Estabilidade</b><span id="C">--</span></div>
      <div class="abcline"><b>Grau</b><span id="R">--</span></div>
    </div>

    <div class="hr"></div>

    <div class="small" style="font-weight:900; letter-spacing:.3px;">Sub-índices</div>
    <div class="grid2">
      <div class="kv"><b>IBE</b><span id="ibe">--</span></div>
      <div class="kv"><b>IAB</b><span id="iab">--</span></div>
      <div class="kv"><b>IBI</b><span id="ibi">--</span></div>
      <div class="kv"><b>HID</b><span id="hid">--</span></div>
      <div class="kv"><b>ENT</b><span id="ent">--</span></div>
      <div class="kv"><b>PAN</b><span id="pan">--</span></div>
    </div>

    <div id="status">Status: iniciando…</div>
  </div>

  <div id="center" class="glass">
    <div id="mapWrap">
      <canvas id="cnvBase"   class="layer"></canvas>
      <canvas id="cnvFill"   class="layer"></canvas>
      <canvas id="cnvBorder" class="layer"></canvas>
      <canvas id="cnvLines"  class="layer"></canvas>
      <canvas id="cnvPoints" class="layer"></canvas>
      <canvas id="cnvAlerts" class="layer"></canvas>
      <div id="mapGlow"></div>
      <div id="scanlines"></div>
    </div>
  </div>

  <div id="right">
    <div id="buy" class="glass">
      <h2>COMPRAR CNT</h2>
      <p class="mut">Abre o token no Pump.fun.</p>

      <label for="sol">Contribuição</label>
      <div class="row">
        <input id="sol" type="number" step="0.01" min="0" value="0.10" />
        <button class="btn" id="btnBuy">Comprar no Pump</button>
      </div>

      <div class="valueLine">Estimativa: <b id="out">-- CNT</b></div>
      <div class="smallnote">Estimativa demo (não é cotação real).</div>
    </div>

    <div id="telemetry" class="glass">
      <div id="telemetryTitle">TELEMETRIA — Série 10 anos</div>
      <canvas id="wave"></canvas>
      <div id="telemetryHint">Carregando…</div>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const PUMP_URL = "https://pump.fun/coin/GCVyjNaCbXkwGUuktyNxSXad4ozmTp2fzQr2jieSpump";
const rate = 147449130;

const FILES = {
  dados: "dados_cnt.json",
  br: "BR_IBGE.geojson",
  uf: "uf.geojson",
  macro: "macro_rh.geojson",
  micro: "micro_rh.geojson",

  pts_water: "agua_pts_sample.geojson",
  pts_vege_sample: "vege_pts_sample.geojson",
  pts_vege_full: "vege_pts.geojson",
  pts_trans: "trans_pts_sample.geojson",
  pts_desm: "desm_pts_sample.geojson",
};

const COLORS = {
  water: [0, 190, 255],
  vege:  [60, 255, 180],
  trans: [255, 235, 90],
  desm:  [255, 80, 60],
  alert: [255, 70, 40]
};

/* =========================
   HELPERS
========================= */
const statusEl = document.getElementById("status");
const chipPts = document.getElementById("chipPts");
const chipAlerts = document.getElementById("chipAlerts");

function fmt(n, d=2){
  if(n === null || n === undefined || !Number.isFinite(Number(n))) return "--";
  return Number(n).toFixed(d).replace(".", ",");
}
function fmt1(n){ return fmt(n,1); }

async function loadJSON(path){
  const url = "./" + path + "?v=" + Date.now();
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error(`${path} HTTP ${res.status}`);
  const txt = await res.text();
  try{ return JSON.parse(txt); }
  catch(e){ throw new Error(`${path}: JSON inválido / truncado`); }
}

function walkCoords(arr, cb){
  if(!arr) return;
  if(typeof arr[0] === "number") cb(arr);
  else for(const a of arr) walkCoords(a, cb);
}
function calcBBox(fc){
  let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    walkCoords(g.coordinates, (c)=>{
      const x=c[0], y=c[1];
      if(x<minx)minx=x; if(y<miny)miny=y;
      if(x>maxx)maxx=x; if(y>maxy)maxy=y;
    });
  }
  return [minx, miny, maxx, maxy];
}

/* =========================
   PROJEÇÃO (TUDO EM CIMA DO IBGE)
========================= */
let bbox = null;
function proj(lon, lat, w, h){
  const [minx,miny,maxx,maxy] = bbox;
  const pad = 0.035;

  const x0 = pad*w, y0 = pad*h;
  const W  = (1-2*pad)*w;
  const H  = (1-2*pad)*h;

  const x = x0 + ((lon - minx) / (maxx - minx)) * W;
  const y = y0 + ((maxy - lat) / (maxy - miny)) * H;
  return [x,y];
}

/* =========================
   CANVAS
========================= */
const cnvBase   = document.getElementById("cnvBase");
const cnvFill   = document.getElementById("cnvFill");
const cnvBorder = document.getElementById("cnvBorder");
const cnvLines  = document.getElementById("cnvLines");
const cnvPoints = document.getElementById("cnvPoints");
const cnvAlerts = document.getElementById("cnvAlerts");

const ctxBase = cnvBase.getContext("2d");
const ctxF    = cnvFill.getContext("2d");
const ctxB    = cnvBorder.getContext("2d");
const ctxL    = cnvLines.getContext("2d");
const ctxP    = cnvPoints.getContext("2d");
const ctxA    = cnvAlerts.getContext("2d");

function resizeCanvas(cnv, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const r = cnv.getBoundingClientRect();
  cnv.width  = Math.floor(r.width * dpr);
  cnv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function clearC(ctx){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctx.clearRect(0,0,W,H);
}
function resizeAll(){
  resizeCanvas(cnvBase, ctxBase);
  resizeCanvas(cnvFill, ctxF);
  resizeCanvas(cnvBorder, ctxB);
  resizeCanvas(cnvLines, ctxL);
  resizeCanvas(cnvPoints, ctxP);
  resizeCanvas(cnvAlerts, ctxA);
  resizeWave();

  if(state.ready){
    brPath2D = null;
    redrawStatic();
    rebuildAllPoints(); // recalcula pontos na resolução nova
  }
}
window.addEventListener("resize", resizeAll);

/* =========================
   BRASIL PATH + BASE HOLO (SEM PNG)
========================= */
let brPath2D = null;

function buildBrasilPath2D(fc){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  const p = new Path2D();

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;

    const polys =
      (g.type === "Polygon") ? [g.coordinates] :
      (g.type === "MultiPolygon") ? g.coordinates : [];

    for(const poly of polys){
      const outer = poly[0];
      if(!outer || outer.length < 3) continue;

      for(let i=0;i<outer.length;i++){
        const [x,y] = proj(outer[i][0], outer[i][1], W, H);
        if(i===0) p.moveTo(x,y); else p.lineTo(x,y);
      }
      p.closePath();
    }
  }
  brPath2D = p;
}

/* FALLBACK: se seus geojson vierem sem Point/MultiPoint, gera “pontos imagem_base” dentro do Brasil */
function makeFallbackDotsInsideBrasil(qty = 14000){
  const W = cnvPoints.getBoundingClientRect().width;
  const H = cnvPoints.getBoundingClientRect().height;
  if(!brPath2D) return [];

  const pts = [];
  let tries = 0;

  while(pts.length < qty && tries < qty * 30){
    tries++;
    const x = Math.random() * W;
    const y = Math.random() * H;
    if(ctxB.isPointInPath(brPath2D, x, y)){
      pts.push({x,y, ph: Math.random()*Math.PI*2, sp: 0.7+Math.random()*1.3});
    }
  }
  return pts;
}

function drawBackgroundBase(){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;

  ctxBase.clearRect(0,0,W,H);
  ctxBase.fillStyle = "#000";
  ctxBase.fillRect(0,0,W,H);

  const vg = ctxBase.createRadialGradient(W*0.52,H*0.46, 10, W*0.52,H*0.46, Math.max(W,H)*0.75);
  vg.addColorStop(0, "rgba(0,0,0,0)");
  vg.addColorStop(1, "rgba(0,0,0,0.60)");
  ctxBase.fillStyle = vg;
  ctxBase.fillRect(0,0,W,H);
}

function fillBrasilHolografico(){
  const W = cnvFill.getBoundingClientRect().width;
  const H = cnvFill.getBoundingClientRect().height;

  ctxF.clearRect(0,0,W,H);
  if(!brPath2D) return;

  ctxF.save();
  ctxF.clip(brPath2D);

  // base leve (não estoura)
  const g = ctxF.createLinearGradient(W*0.20, H*0.20, W*0.85, H*0.80);
  g.addColorStop(0.00, "rgba(0, 170, 255, 0.10)");
  g.addColorStop(0.45, "rgba(0, 255, 210, 0.08)");
  g.addColorStop(1.00, "rgba(0, 120, 255, 0.10)");
  ctxF.fillStyle = g;
  ctxF.fillRect(0,0,W,H);

  // textura holográfica suave
  ctxF.globalCompositeOperation = "screen";
  ctxF.globalAlpha = 0.08;
  for(let i=0;i<220;i++){
    const x = Math.random()*W;
    const y = Math.random()*H;
    const r = 8 + Math.random()*28;
    const gg = ctxF.createRadialGradient(x,y, 0, x,y, r);
    gg.addColorStop(0, "rgba(120,220,255,0.45)");
    gg.addColorStop(1, "rgba(0,0,0,0)");
    ctxF.fillStyle = gg;
    ctxF.beginPath();
    ctxF.arc(x,y,r,0,Math.PI*2);
    ctxF.fill();
  }

  // scanlines internas
  ctxF.globalCompositeOperation = "overlay";
  ctxF.globalAlpha = 0.10;
  ctxF.fillStyle = "rgba(120,220,255,0.20)";
  for(let y=0; y<H; y+=8){
    ctxF.fillRect(0,y,W,1);
  }

  ctxF.restore();
  ctxF.globalCompositeOperation = "source-over";
  ctxF.globalAlpha = 1;
}

/* =========================
   DRAW BORDER + LINES
========================= */
function strokePolygonsGlow(ctx, fc){
  const W = cnvBorder.getBoundingClientRect().width;
  const H = cnvBorder.getBoundingClientRect().height;

  ctx.save();
  ctx.lineJoin="round";
  ctx.lineCap="round";

  const drawOuter = ()=>{
    for(const f of (fc.features||[])){
      const g = f.geometry;
      if(!g) continue;
      const polys = (g.type==="Polygon") ? [g.coordinates] : (g.type==="MultiPolygon" ? g.coordinates : []);
      for(const poly of polys){
        const outer = poly[0];
        if(!outer || outer.length<3) continue;
        ctx.beginPath();
        for(let i=0;i<outer.length;i++){
          const [x,y] = proj(outer[i][0], outer[i][1], W, H);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  };

  ctx.shadowColor = "rgba(0,255,220,0.90)";
  ctx.shadowBlur  = 18;
  ctx.lineWidth   = 3.6;
  ctx.strokeStyle = "rgba(0,255,220,0.45)";
  drawOuter();

  ctx.shadowBlur  = 8;
  ctx.lineWidth   = 1.9;
  ctx.strokeStyle = "rgba(0,255,220,0.95)";
  drawOuter();

  ctx.restore();
}

function strokeLines(ctx, fc, strokeStyle, width, alpha){
  const W = cnvBase.getBoundingClientRect().width;
  const H = cnvBase.getBoundingClientRect().height;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = width;
  ctx.lineJoin="round";
  ctx.lineCap="round";

  const drawLine = (line)=>{
    if(!line || line.length<2) return;
    ctx.beginPath();
    for(let i=0;i<line.length;i++){
      const [x,y]=proj(line[i][0], line[i][1], W, H);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  };

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;
    if(g.type==="LineString") drawLine(g.coordinates);
    else if(g.type==="MultiLineString") for(const ln of g.coordinates) drawLine(ln);
    else if(g.type==="Polygon") drawLine(g.coordinates[0]);
    else if(g.type==="MultiPolygon") for(const poly of g.coordinates) drawLine(poly[0]);
  }

  ctx.restore();
}

/* =========================
   PONTOS (ACEITA Point/MultiPoint/GeometryCollection)
========================= */
function projectPoints(fc){
  const W = cnvPoints.getBoundingClientRect().width;
  const H = cnvPoints.getBoundingClientRect().height;

  const pts = [];
  const pushOne = (lon, lat)=>{
    const [x,y] = proj(lon, lat, W, H);
    pts.push({x,y, ph: Math.random()*Math.PI*2, sp: 0.7+Math.random()*1.3});
  };

  for(const f of (fc.features||[])){
    const g = f.geometry;
    if(!g) continue;

    if(g.type === "Point"){
      pushOne(g.coordinates[0], g.coordinates[1]);
    }
    else if(g.type === "MultiPoint"){
      for(const c of g.coordinates) pushOne(c[0], c[1]);
    }
    else if(g.type === "GeometryCollection"){
      for(const gg of (g.geometries||[])){
        if(!gg) continue;
        if(gg.type === "Point") pushOne(gg.coordinates[0], gg.coordinates[1]);
        else if(gg.type === "MultiPoint"){
          for(const c of gg.coordinates) pushOne(c[0], c[1]);
        }
      }
    }
  }
  return pts;
}

/* cria uma camada “dot holográfico” (pré-render) */
function buildDotLayer(points, colorRGB){
  const W = Math.max(1, Math.floor(cnvPoints.getBoundingClientRect().width));
  const H = Math.max(1, Math.floor(cnvPoints.getBoundingClientRect().height));

  const off = document.createElement("canvas");
  off.width = W;
  off.height = H;
  const octx = off.getContext("2d", { alpha:true });

  const [r,g,b] = colorRGB;

  octx.clearRect(0,0,W,H);
  octx.save();

  // glow
  octx.fillStyle = `rgba(${r},${g},${b},0.62)`;
  octx.shadowColor = `rgba(${r},${g},${b},0.82)`;
  octx.shadowBlur = 10;

  for(const p of points){
    octx.beginPath();
    octx.arc(p.x, p.y, 1.05, 0, Math.PI*2);
    octx.fill();
  }

  // pixel nítido
  octx.shadowBlur = 0;
  octx.fillStyle = `rgba(${r},${g},${b},0.45)`;
  for(const p of points){
    octx.fillRect(p.x, p.y, 1, 1);
  }

  octx.restore();
  return off;
}

function drawDotLayer(offCanvas, alpha, blurPx){
  if(!offCanvas) return;
  const W = cnvPoints.getBoundingClientRect().width;
  const H = cnvPoints.getBoundingClientRect().height;

  ctxP.save();
  ctxP.globalCompositeOperation = "lighter";
  ctxP.globalAlpha = alpha;

  if(blurPx > 0) ctxP.filter = `blur(${blurPx}px)`;
  ctxP.drawImage(offCanvas, 0, 0, W, H);

  ctxP.filter = "none";
  ctxP.globalAlpha = 1;
  ctxP.globalCompositeOperation = "source-over";
  ctxP.restore();
}

/* =========================
   ALERTAS
========================= */
function drawAlerts(items){
  const W = cnvAlerts.getBoundingClientRect().width;
  const H = cnvAlerts.getBoundingClientRect().height;
  ctxA.clearRect(0,0,W,H);

  if(!items || !items.length) return;

  ctxA.save();
  ctxA.globalCompositeOperation = "lighter";
  for(const it of items){
    const [x,y] = proj(it.lon, it.lat, W, H);
    const pulse = 0.55 + 0.45*Math.sin(state.t*0.08);

    ctxA.shadowBlur = 22;
    ctxA.shadowColor = `rgba(${COLORS.alert[0]},${COLORS.alert[1]},${COLORS.alert[2]},0.85)`;
    ctxA.fillStyle = `rgba(${COLORS.alert[0]},${COLORS.alert[1]},${COLORS.alert[2]},${0.18 + 0.22*pulse})`;
    ctxA.beginPath();
    ctxA.arc(x, y, 6 + pulse*8, 0, Math.PI*2);
    ctxA.fill();

    ctxA.shadowBlur = 10;
    ctxA.fillStyle = `rgba(255,255,255,${0.25 + 0.35*pulse})`;
    ctxA.beginPath();
    ctxA.arc(x, y, 1.4 + pulse*1.4, 0, Math.PI*2);
    ctxA.fill();
  }
  ctxA.restore();
}

/* =========================
   STATE
========================= */
const state = {
  ready:false,
  dados:null,
  brasil:null,
  uf:null,
  macro:null,
  micro:null,

  pts: { water: [], vege: [], trans: [], desm: [] },
  dots:{ water:null, vege:null, trans:null, desm:null },

  loadedFull:false,
  alerts: [],

  fcCache: { water:null, vege:null, trans:null, desm:null },

  t:0,
  raf:null
};

function rebuildDots(){
  state.dots.water = state.pts.water.length ? buildDotLayer(state.pts.water, COLORS.water) : null;
  state.dots.vege  = state.pts.vege.length  ? buildDotLayer(state.pts.vege,  COLORS.vege)  : null;
  state.dots.trans = state.pts.trans.length ? buildDotLayer(state.pts.trans, COLORS.trans) : null;
  state.dots.desm  = state.pts.desm.length  ? buildDotLayer(state.pts.desm,  COLORS.desm)  : null;

  const total = state.pts.water.length + state.pts.vege.length + state.pts.trans.length + state.pts.desm.length;
  chipPts.textContent = `Pontos: ${total.toLocaleString('pt-BR')} (4 cores)`;
}

function rebuildAllPoints(){
  if(!state.fcCache.water || !bbox) return;

  state.pts.water = projectPoints(state.fcCache.water);
  state.pts.vege  = projectPoints(state.fcCache.vege);
  state.pts.trans = projectPoints(state.fcCache.trans);
  state.pts.desm  = projectPoints(state.fcCache.desm);

  rebuildDots();
}

/* =========================
   STATIC REDRAW
========================= */
function redrawStatic(){
  if(!bbox) return;

  clearC(ctxBase); clearC(ctxF); clearC(ctxB); clearC(ctxL);

  drawBackgroundBase();

  if(!brPath2D) buildBrasilPath2D(state.brasil);
  fillBrasilHolografico();

  strokePolygonsGlow(ctxB, state.brasil);

  strokeLines(ctxL, state.macro, "rgba(0,234,255,0.70)", 1.00, 1);
  strokeLines(ctxL, state.micro, "rgba(0,120,255,0.45)", 0.55, 1);
  strokeLines(ctxL, state.uf,    "rgba(160,245,255,0.55)", 0.95, 1);
}

/* =========================
   ANIMAÇÃO — DOT HOLOGRÁFICO
========================= */
function startAnim(){
  if(state.raf) cancelAnimationFrame(state.raf);

  const loop = ()=>{
    const W = cnvPoints.getBoundingClientRect().width;
    const H = cnvPoints.getBoundingClientRect().height;
    ctxP.clearRect(0,0,W,H);

    const pulse = 0.70 + 0.30*Math.sin(state.t*0.03);

    // halo (blur)
    drawDotLayer(state.dots.water, 0.22 * pulse, 12);
    drawDotLayer(state.dots.vege,  0.26 * pulse, 14);
    drawDotLayer(state.dots.trans, 0.20 * pulse, 13);
    drawDotLayer(state.dots.desm,  0.20 * pulse, 13);

    // nítido
    drawDotLayer(state.dots.water, 0.36 * pulse, 0);
    drawDotLayer(state.dots.vege,  0.42 * pulse, 0);
    drawDotLayer(state.dots.trans, 0.32 * pulse, 0);
    drawDotLayer(state.dots.desm,  0.32 * pulse, 0);

    drawAlerts(state.alerts);

    state.t++;
    state.raf = requestAnimationFrame(loop);
  };
  state.raf = requestAnimationFrame(loop);
}

/* =========================
   TELEMETRY
========================= */
const wave = document.getElementById("wave");
const wctx = wave.getContext("2d");
let tWave=0;

function resizeWave(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  wave.width = Math.floor(wave.clientWidth * dpr);
  wave.height = Math.floor(wave.clientHeight * dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0);
}

function startWave(series){
  const s = Array.isArray(series) ? series : [];
  const draw = ()=>{
    const W = wave.clientWidth, H = wave.clientHeight;
    wctx.clearRect(0,0,W,H);
    wctx.fillStyle = "rgba(0,0,0,.25)";
    wctx.fillRect(0,0,W,H);

    wctx.strokeStyle = "rgba(110,210,255,.10)";
    wctx.lineWidth = 1;
    for(let y=12; y<H; y+=18){
      wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
    }

    const min = s.length? Math.min(...s) : 0;
    const max = s.length? Math.max(...s) : 1;

    function yAt(i){
      if(s.length>=2){
        const idx = (i / (W-1)) * (s.length-1);
        const a = Math.floor(idx);
        const b = Math.min(s.length-1, a+1);
        const f = idx - a;
        const v = s[a]*(1-f) + s[b]*f;
        const norm = (max-min) < 1e-9 ? 0.5 : (v - min) / (max - min);
        let y = (H*0.18) + (1-norm) * (H*0.68);
        y += Math.sin((i + tWave)/28) * (H*0.02);
        return y;
      }
      return (H*0.52)
        + Math.sin((i+tWave)/38)*(H*0.20)
        + Math.sin((i+tWave)/13)*(H*0.07);
    }

    wctx.lineWidth = 2;
    wctx.strokeStyle = "rgba(110,210,255,.35)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    wctx.strokeStyle = "rgba(110,210,255,.90)";
    wctx.beginPath();
    for(let i=0;i<W;i++){
      const y = yAt(i);
      if(i===0) wctx.moveTo(i,y); else wctx.lineTo(i,y);
    }
    wctx.stroke();

    tWave += 2;
    requestAnimationFrame(draw);
  };
  draw();
}

/* =========================
   BUY
========================= */
const solInput = document.getElementById("sol");
const out = document.getElementById("out");
function updateOut(){
  const sol = parseFloat(solInput.value) || 0;
  out.textContent = (sol * rate).toLocaleString("pt-BR") + " CNT";
}
solInput.addEventListener("input", updateOut);
updateOut();
document.getElementById("btnBuy").addEventListener("click", ()=>{
  window.open(PUMP_URL, "_blank", "noopener,noreferrer");
});

/* =========================
   HUD (dados_cnt.json)
========================= */
function applyHUD(d){
  const meta = d?.meta || {};
  const idx = d?.indices || {};

  document.getElementById("chipSource").textContent = `Fonte: ${meta.source || 'dados públicos'}`;
  document.getElementById("chipYear").textContent = `Ano base: ${meta.year_base ?? 2025}`;

  const rawA = Number(idx.cnt_A_raw);
  const A100 = Number(idx.cnt_A_0_100);

  document.getElementById("raw").textContent = fmt(rawA,2);
  document.getElementById("eco").textContent = fmt1(A100);
  document.getElementById("A").textContent   = fmt(A100,2);

  const b = Number(idx.cnt_B);
  document.getElementById("B").textContent = Number.isFinite(b) ? ((b>=0?"+":"") + fmt(b,2)) : "--";
  document.getElementById("C").textContent = fmt(idx.cnt_C,2);
  document.getElementById("R").textContent = idx.grade || "--";

  const sub = idx.sub || {};
  document.getElementById("ibe").textContent = Number.isFinite(Number(sub.IBE)) ? fmt(sub.IBE,1) : "--";
  document.getElementById("iab").textContent = Number.isFinite(Number(sub.IAB)) ? fmt(sub.IAB,1) : "--";
  document.getElementById("ibi").textContent = Number.isFinite(Number(sub.IBI)) ? fmt(sub.IBI,1) : "--";
  document.getElementById("hid").textContent = Number.isFinite(Number(sub.HID)) ? fmt(sub.HID,1) : "--";
  document.getElementById("ent").textContent = Number.isFinite(Number(sub.ENT)) ? fmt(sub.ENT,1) : "--";
  document.getElementById("pan").textContent = Number.isFinite(Number(sub.PAN)) ? fmt(sub.PAN,1) : "--";

  const series = Array.isArray(idx.series_10y) ? idx.series_10y.map(Number).filter(Number.isFinite) : [];
  document.getElementById("telemetryHint").textContent = series.length
    ? (`Histórico: ${series.length} • Último (0-100): ${fmt1(series[series.length-1])}`)
    : "Sem série 10y.";

  startWave(series);

  const alerts = d?.alerts?.items || [];
  state.alerts = alerts.slice(0, (d?.alerts?.max_render ?? 220));
  chipAlerts.textContent = `Alertas: ${state.alerts.length} ativos`;
}

/* =========================
   BOOT
========================= */
async function boot(){
  try{
    statusEl.textContent = "Status: carregando dados e camadas base…";
    resizeAll();

    state.dados = await loadJSON(FILES.dados);
    applyHUD(state.dados);

    state.brasil = await loadJSON(FILES.br);
    bbox = calcBBox(state.brasil);

    state.uf = await loadJSON(FILES.uf);
    state.macro = await loadJSON(FILES.macro);
    state.micro = await loadJSON(FILES.micro);

    state.ready = true;

    brPath2D = null;
    redrawStatic();

    statusEl.textContent = "Status: base IBGE OK • carregando pontos…";

    const [fcWater, fcVege, fcTrans, fcDesm] = await Promise.all([
      loadJSON(FILES.pts_water),
      loadJSON(FILES.pts_vege_sample),
      loadJSON(FILES.pts_trans),
      loadJSON(FILES.pts_desm)
    ]);

    state.fcCache.water = fcWater;
    state.fcCache.vege  = fcVege;
    state.fcCache.trans = fcTrans;
    state.fcCache.desm  = fcDesm;

    rebuildAllPoints();

    // SE DER 0 PONTOS: fallback “imagem_base”
    const tot = state.pts.water.length + state.pts.vege.length + state.pts.trans.length + state.pts.desm.length;
    if(tot === 0){
      statusEl.textContent = "Status: pontos GeoJSON não vieram como Point/MultiPoint — usando fallback (imagem_base)";
      state.pts.vege  = makeFallbackDotsInsideBrasil(18000);
      state.pts.water = makeFallbackDotsInsideBrasil(8000);
      state.pts.trans = makeFallbackDotsInsideBrasil(9000);
      state.pts.desm  = makeFallbackDotsInsideBrasil(7000);
      rebuildDots();
    }

    startAnim();

    statusEl.textContent =
      "Status: holografia OK (dot-field)\n" +
      "Cores: verde=vegetação • azul=água • amarelo=transição • vermelho=desmatamento";

  }catch(err){
    console.error(err);
    statusEl.textContent = "Status: ERRO • " + (err?.message || err);
    document.getElementById("telemetryHint").textContent = "Erro ao carregar arquivos. Veja o console (F12).";
  }
}

// FULL vegetation manual
async function loadFullVege(){
  if(state.loadedFull) return;
  try{
    statusEl.textContent = "Status: carregando FULL de vegetação…";
    const fc = await loadJSON(FILES.pts_vege_full);
    state.fcCache.vege = fc;
    state.loadedFull = true;

    rebuildAllPoints();

    statusEl.textContent = "Status: FULL de vegetação OK • holografia contínua";
    document.getElementById('btnFull').textContent = "FULL carregado";
  }catch(e){
    statusEl.textContent = "Status: FULL indisponível/erro • mantendo sample";
  }
}
document.getElementById("btnFull").addEventListener("click", loadFullVege);

boot();
</script>
</body>
</html>
